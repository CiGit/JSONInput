{"version":3,"file":"index.es2015.js","sources":["../src/Comps/defaultWidgets.tsx","../src/Comps/Fields/Widget.tsx","../src/Utils/customValidator.ts","../src/Store/actions.ts","../src/Comps/Decorators/validator.tsx","../src/Comps/Fields/Object.tsx","../src/Comps/Fields/String.tsx","../src/Comps/Fields/Boolean.tsx","../src/Comps/Fields/Array.tsx","../src/Comps/Decorators/visible.tsx","../src/Comps/Fields/Undefined.tsx","../src/Utils/infer.ts","../src/Comps/Decorators/inference.tsx","../src/Comps/Decorators/fromDefaultValue.tsx","../src/Comps/Container.tsx","../src/Store/index.ts","../src/Comps/Fields/Number.tsx","../src/Comps/Fields/index.tsx","../src/Comps/SchemaType.tsx"],"sourcesContent":["import * as React from 'react';\nimport { WidgetProps } from '../../typings/types';\n\nexport type WidgetMap = {\n    [key: string]: React.ComponentClass<WidgetProps> | React.SFC<WidgetProps>;\n};\n\nfunction undefinedWidgetFactory(type: string) {\n    return function UndefinedWidget() {\n        return <span>{`Widget for '${type}' was not defined`}</span>;\n    };\n}\nlet DefaultWidget: WidgetMap = {};\n\nfunction defaultWidget(type: string) {\n    return DefaultWidget[type] || undefinedWidgetFactory(type);\n}\n\nfunction setDefaultWidgets(obj: WidgetMap) {\n    DefaultWidget = Object.assign({}, DefaultWidget, obj);\n}\n\nexport { defaultWidget, setDefaultWidgets };\n","import * as React from 'react';\nimport { defaultWidget } from '../defaultWidgets';\n\nimport { WidgetProps, TYPESTRING, Schema } from '../../../typings/types';\n\ntype Props = {\n    value?: {};\n    schema: Schema & { type: TYPESTRING };\n    editKey: string;\n    onChange: (value: any) => void;\n    errorMessage?: string[];\n    path: string[];\n    children?: (React.ComponentClass<WidgetProps> | React.SFC<WidgetProps>)[];\n    addKey?: (key: string, value: {}) => void;\n    removeKey?: (key: string) => void;\n    alterKey?: (key: string, newKey: string) => void;\n    onChildAdd?: () => void;\n    onChildRemove?: (index: number) => void;\n};\n\nconst EMPTYOBJECT = {};\nfunction Widget<P extends Props>(props: P) {\n    const {\n        value,\n        schema,\n        schema: { view },\n        children,\n        editKey,\n        path,\n        onChange,\n        onChildAdd,\n        onChildRemove,\n        addKey,\n        removeKey,\n        alterKey,\n        errorMessage,\n    } = props;\n    const forwardProps = {\n        value,\n        schema,\n        children,\n        editKey,\n        path,\n        onChange,\n        onChildAdd,\n        onChildRemove,\n        addKey,\n        removeKey,\n        alterKey,\n        errorMessage,\n    };\n    if (view) {\n        const { type } = view;\n        if (typeof type === 'string') {\n            const Wdgt = defaultWidget(type);\n            return <Wdgt {...forwardProps} view={view} />;\n        }\n        if (typeof type === 'function') {\n            const Type = type;\n            return <Type {...forwardProps} view={view} />;\n        }\n    }\n    let renderType = Array.isArray(schema.type)\n        ? (schema.type as TYPESTRING[]).find(t => t !== 'null')\n        : schema.type;\n    let Wdgt;\n    if (renderType === undefined) {\n        Wdgt = defaultWidget('undefinedType');\n    } else {\n        Wdgt = defaultWidget(renderType);\n    }\n    return <Wdgt {...forwardProps} view={view || EMPTYOBJECT} />;\n}\n\nexport default Widget;\n","import * as jsonschema from 'jsonschema';\nimport { ValidatorResult } from \"jsonschema/lib\";\nimport { Schema, ErrorFn } from '../../typings/types';\n\nconst customValidator = new jsonschema.Validator();\ncustomValidator.attributes.errored = function validateErrored(\n    instance: {},\n    schema: { errored?: ErrorFn },\n    options: { formValue: {} }\n) {\n    if (typeof schema.errored !== 'function') {\n        throw new jsonschema.SchemaError('\"errored\" expects a function');\n    }\n    const msg = schema.errored(instance, options.formValue);\n    if (msg) {\n        return msg;\n    }\n    return undefined;\n};\nfunction validate(\n    value: {},\n    schema: Schema,\n    formValue: {}\n): ValidatorResult {\n    return customValidator.validate(value, schema, { formValue });\n}\n\nexport default validate;\n","import { ValidationError } from 'jsonschema/lib';\n\n/*\nEvery tree should be of type Baobab\n*/\nconst VALUE = 'value';\nconst STATUS = 'status';\nconst STATE = 'state';\nconst ERRORS = 'errors';\nconst NO_ERRORS: string[] = [];\n\nfunction setErrors(tree: any, path: string[] = [], errors: string[]) {\n    const errorPath = [STATUS].concat(path).concat([ERRORS]);\n    const errorsCursor = tree.select(errorPath);\n    if (errors && errors.length && Array.isArray(errorsCursor.get())) {\n        errorsCursor.splice([0, errorsCursor.get().length]);\n        errorsCursor.concat(errors || []);\n    } else {\n        errorsCursor.set(errors || NO_ERRORS);\n    }\n}\nexport function setValidationErrors(\n    tree: any,\n    path: string[] = [],\n    errors: ValidationError[]\n) {\n    const errorMap = new Map<string, string[]>();\n    // Collect each error associated with a given path\n    errors.forEach(error => {\n        const errors = errorMap.get(error.property) || [];\n        errors.push(error.message); // Add new error\n        errorMap.set(error.property, errors);\n    });\n    setErrors(tree, path, NO_ERRORS);\n    errorMap.forEach((value, key) => {\n        setErrors(\n            tree,\n            path.concat(\n                key\n                    .split(/\\.|\\[|\\]/)\n                    .filter(x => x !== '')\n                    .slice(1)\n            ),\n            value\n        );\n    });\n}\n\n/**\n * Update a value in the tree\n *\n * @param {Baobab} tree the tree\n * @param {Array<string>} path path's value to update\n * @param value value to set\n * @param {Array<string>} errors errors relative to the value\n */\nexport function update(\n    tree: any,\n    path: string[] = [],\n    value: {},\n    errors: ValidationError[]\n) {\n    const statusPath = [STATUS].concat(path);\n    tree.set([VALUE].concat(path), value);\n    tree.set(statusPath.concat([STATE]), 'dirty');\n    setValidationErrors(tree, path, errors);\n}\n\nexport function setDefaultValue(tree: any, path: string[] = [], value: {}) {\n    tree.set([VALUE].concat(path), value);\n    tree.set([STATUS].concat(path).concat([STATE]), 'pristine');\n}\n\nexport function getStatus(tree: any, path: string[] = []) {\n    const statePath = [STATUS].concat(path).concat([STATE]);\n    if (tree.exists(statePath)) {\n        return tree.get([STATUS].concat(path).concat([STATE]));\n    }\n    return undefined;\n}\n\nexport function getErrors(tree: any, path: string[] = []) {\n    return tree.get([STATUS].concat(path).concat([ERRORS])) || NO_ERRORS;\n}\n\nexport function getFormValue(tree: any) {\n    return tree.get(VALUE);\n}\n","import * as React from 'react';\nimport validate from './../../Utils/customValidator';\nimport { getFormValue, getErrors } from '../../Store/actions';\n\nimport { Schema, Action } from '../../../typings/types';\nimport { ValidationError } from 'jsonschema/lib';\n\ntype Props = {\n    schema: Schema;\n    value?: {};\n    dispatch: (action: Action, ...args: {}[]) => any;\n    path: string[];\n    onChange: (value: {}, errors?: ValidationError[]) => void;\n};\n\nfunction validated<P extends Props>(\n    Comp: React.ComponentClass<any> | React.SFC<any>\n) {\n    function Validator(props: P) {\n        function onChange(val: {}): void {\n            const validation = validate(\n                val,\n                props.schema,\n                props.dispatch(getFormValue)\n            );\n            props.onChange(val, validation.errors);\n        }\n        // console.log(getErrors);\n        return (\n            <Comp\n                {...props}\n                errorMessage={props.dispatch(getErrors, props.path)}\n                onChange={onChange}\n            />\n        );\n    }\n    return Validator;\n}\n\nexport default validated;\n","import * as React from 'react';\nimport SchemaType from '../SchemaType';\nimport Widget from './Widget';\nimport validator from '../Decorators/validator';\n\nimport { Schema } from '../../../typings/types';\n\ntype Props = {\n    schema: Schema.Object;\n    status: { [key: string]: {} };\n    editKey: string;\n    value: {\n        [key: string]: {};\n    };\n    path: string[];\n    onChange: (value: {}) => void;\n};\n\nconst EMPTY_OBJECT = {};\n\nfunction renderChildren(props: Props): JSX.Element[] {\n    const children = [];\n    const properties = props.schema.properties || {};\n    const value: { [key: string]: {} } = props.value || {};\n    // Holds schema properties and value properties missing from schema.\n    const mergedProperties: Array<string> = Object.keys(properties);\n\n    Object.keys(value).forEach(v => {\n        if (v in properties) {\n            return;\n        }\n        mergedProperties.push(v);\n    });\n    function indexFor(property: string): number {\n        if (properties[property]) {\n            const index = properties[property].index;\n            if (typeof index === 'number') {\n                return index;\n            }\n        }\n        return 0;\n    }\n    // Index based sorting\n    function sortProperties(a: string, b: string): number {\n        return indexFor(a) - indexFor(b);\n    }\n\n    mergedProperties.sort(sortProperties);\n    for (let i: number = 0; i < mergedProperties.length; i += 1) {\n        const prop: string = mergedProperties[i];\n        if (prop in properties) {\n            children.push(\n                <SchemaType\n                    {...props}\n                    status={props.status[prop] || EMPTY_OBJECT}\n                    schema={properties[prop]}\n                    value={value[prop]}\n                    editKey={prop}\n                    key={i}\n                />\n            );\n        } else {\n            const schema = props.schema.additionalProperties;\n            children.push(\n                <SchemaType\n                    {...props}\n                    status={props.status[prop] || EMPTY_OBJECT}\n                    schema={schema}\n                    value={value[prop]}\n                    editKey={prop}\n                    key={i}\n                />\n            );\n        }\n    }\n    return children;\n}\n\nfunction ObjectField(props: Props) {\n    function addKey(key: string, value: {}): void {\n        if (typeof props.value === 'object' && key in props.value) {\n            throw new Error(`Property \"${key}\" already exists`);\n        }\n        props.onChange(\n            Object.assign({}, props.value, {\n                [key]: value,\n            })\n        );\n    }\n\n    function removeKey(key: string): void {\n        const value: { [key: string]: {} } = Object.assign({}, props.value);\n        delete value[key];\n        props.onChange(value);\n    }\n\n    function alterKey(key: string, newKey: string): void {\n        if (key === newKey) {\n            return;\n        }\n        if (newKey in props.value) {\n            throw new Error(`Property \"${key}\" already exists`);\n        }\n        const value: { [key: string]: {} } = {};\n        Object.keys(props.value).forEach(p => {\n            if (p !== key) {\n                value[p] = props.value[p];\n            } else {\n                value[newKey] = props.value[p];\n            }\n        });\n        props.onChange(value);\n    }\n    return (\n        <Widget\n            {...props as any}\n            addKey={addKey}\n            removeKey={removeKey}\n            alterKey={alterKey}\n        >\n            {renderChildren(props)}\n        </Widget>\n    );\n}\n\nexport default validator(ObjectField);\n","import * as React from 'react';\nimport Widget from './Widget';\nimport validator from '../Decorators/validator';\n\nimport { Schema, Action } from '../../../typings/types';\n\ntype Props = {\n    schema: Schema & { type: 'number' | 'string' };\n    value?: number | string;\n    editKey: string;\n    path: string[];\n    onChange: (value: string | number) => void;\n    dispatch: (action: Action, ...args: {}[]) => any;\n};\n\nfunction StringField(props: Props) {\n    return <Widget {...props} />;\n}\n\nexport { StringField as SimpleStringField };\nexport default validator(StringField);\n","import * as React from 'react';\nimport Widget from './Widget';\nimport validator from './../Decorators/validator';\n\nimport{ Schema, Action } from '../../../typings/types';\n\nfunction BooleanField(\n    props: {\n        schema: Schema & { type: 'boolean' },\n        editKey: string,\n        path: string[],\n        value: boolean,\n        onChange: (value?: boolean) => void,\n        dispatch: (action: Action, ...args: {}[]) => any,\n    }\n) {\n    return <Widget {...(props)} />;\n}\n\nexport default validator(BooleanField);\n","import * as React from 'react';\nimport SchemaType from '../SchemaType';\nimport Widget from './Widget';\nimport validator from '../Decorators/validator';\n\nimport { Schema, Action } from '../../../typings/types';\n\ntype Props = {\n    onChange: (val: {}[]) => void;\n    schema: Schema & {\n        type: 'array';\n        items?: Schema[] | Schema;\n        value?: {}[];\n    };\n    dispatch: (action: Action, ...args: {}[]) => any;\n    value?: {}[];\n    editKey: string;\n    status: { [key: string]: {} };\n    path: string[];\n    [key: string]: any;\n};\nconst EMPTY_OBJECT = {};\n\nfunction onChildChange(index: number, props: Props) {\n    return function onChange(val: {}) {\n        const { value } = props;\n        if (value) {\n            props.onChange(\n                value.map((e, i) => {\n                    if (+i !== +index) {\n                        return e;\n                    }\n                    return val;\n                })\n            );\n        } else {\n            props.onChange([val]);\n        }\n    };\n}\n\nfunction onChildRemove(props: Props) {\n    return function onRemove(index: number) {\n        const oldValue = props.value || [];\n        props.onChange(oldValue.filter((e, i) => Number(i) !== Number(index)));\n    };\n}\n\nfunction onChildAdd(props: Props) {\n    return function onAdd(value?: {}) {\n        const oldValue = props.value || [];\n        props.onChange(oldValue.concat([value]));\n    };\n}\n\nfunction renderChildren(props: Props) {\n    const { value, schema: { value: defaultValue, items } } = props;\n    let valueItems: {}[];\n    if (value) {\n        valueItems = value;\n    } else if (defaultValue) {\n        valueItems = defaultValue as {}[];\n    } else {\n        valueItems = [];\n    }\n    const children: JSX.Element[] = [];\n    valueItems.forEach((val, i) =>\n        children.push(\n            <SchemaType\n                {...props}\n                schema={Array.isArray(items) ? items[i] || {} : items}\n                value={val}\n                editKey={String(i)}\n                status={props.status[String(i)] || EMPTY_OBJECT}\n                key={i}\n                onChange={onChildChange(i, props)}\n            />\n        )\n    );\n    return children;\n}\n\nfunction ArrayField(props: Props) {\n    return (\n        <Widget\n            {...props as any}\n            onChildAdd={onChildAdd(props)}\n            onChildRemove={onChildRemove(props)}\n        >\n            {renderChildren(props)}\n        </Widget>\n    );\n}\n\nexport default validator(ArrayField);\n","import * as React from 'react';\nimport { getFormValue } from '../../Store/actions';\nimport { Action, Schema } from '../../../typings/types';\n\ntype Props = {\n    schema: Schema;\n    path: string[];\n    value?: {};\n    dispatch: (action: Action, ...args: {}[]) => any;\n};\nfunction visibility<P extends Props>(\n    Comp: React.ComponentClass<P> | React.SFC<P>\n): React.SFC<P> {\n    return function Visible(props: P) {\n        const { schema: { visible }, value } = props;\n        try {\n            if (\n                visible &&\n                !visible(\n                    value,\n                    props.dispatch(getFormValue),\n                    props.path.concat() // Copy\n                )\n            ) {\n                return null!;\n            }\n        } catch (e) {\n            return null!;\n        }\n        return <Comp {...props} />;\n    };\n}\n\nexport default visibility;\n","import * as React from 'react';\n\nimport { WidgetProps } from '../../../typings/types';\n\nfunction Undefined(props: WidgetProps) {\n    return (\n        <div>{`Undefined field type \"${props.schema.type!.toString()}\", [${props.path.toString()}]`}</div>\n    );\n}\n\nexport default Undefined;\n","export default function infer(value?: {}) {\n    switch (typeof value) {\n        case 'number':\n            return 'number';\n        case 'string':\n            return 'string';\n        case 'boolean':\n            return 'boolean';\n        case 'object':\n            return Array.isArray(value) ? 'array' : 'object';\n        default:\n            return 'string';\n    }\n}\n","import * as React from 'react';\nimport infer from './../../Utils/infer';\nimport { Schema } from '../../../typings/types';\n/**\n * Update store's value path.\n * @param {Array<string>} currentValuePath the valuePath the parent\n * @param {string} editKey the key currently edited\n * @returns {Array<string>}the updated valuePath\n */\nfunction updatePath(currentPath: string[], editKey?: string): string[] {\n    if (editKey !== undefined) {\n        return currentPath.concat([editKey]);\n    }\n    return currentPath;\n}\ntype Props = {\n    path: string[],\n    editKey?: string,\n    value?: {},\n    schema?: Schema\n};\n\n/**\n * HOC, compute schema value from inferred type if schema is missing\n * @param {React.Component} Comp component to decorate.\n * @return {React.Component} the decorated component.\n */\nfunction inference<P extends Props>(\n    Comp: React.ComponentClass<P> | React.SFC<P>\n) {\n    class Infer extends React.Component<Partial<P> & Props, { schema: Schema }> {\n        path: string[];\n        state: {\n            schema: Schema\n        };\n        constructor(props: P) {\n            super(props);\n            const { schema } = props;\n            let inferredSchema = schema || {};\n            if (!('type' in inferredSchema)) {\n                inferredSchema = { type: infer(props.value), ...inferredSchema };\n            }\n            this.state = { schema: inferredSchema };\n            this.path = updatePath(this.props.path, this.props.editKey);\n        }\n        componentWillReceiveProps(nextProps: P) {\n            if(nextProps.editKey !== this.props.editKey || nextProps.path !== this.props.path){\n                this.path = updatePath(nextProps.path, nextProps.editKey);\n            }\n            if (this.props.schema !== nextProps.schema) {\n                let inferredSchema = nextProps.schema || {};\n                if (!('type' in inferredSchema)) {\n                    inferredSchema = { type: infer(nextProps.value), ...inferredSchema };\n                }\n                this.setState(() => ({ schema: inferredSchema }));\n            }\n        }\n        render() {\n            return (\n                <Comp {...(this.props) } path={this.path} schema={this.state.schema} />\n            );\n        }\n    }\n    return Infer;\n}\n\nexport default inference;\n","import * as React from 'react';\nimport { setDefaultValue } from '../../Store/actions';\nimport { Action, Schema } from '../../../typings/types';\n\nexport type Props = {\n    editKey?: string;\n    path: string[];\n    status: {\n        state?: string;\n    };\n    value?: {};\n    schema: Schema;\n    dispatch: (action: Action, ...args: ({} | void)[]) => any;\n};\nfunction updateDefault({ value, schema: { value: defaultValue } }: Props) {\n    const val = value !== undefined ? value : defaultValue;\n    return val;\n}\n\nfunction fromDefaultValue<P extends Props>(\n    Comp: React.ComponentClass<P> | React.SFC<P>\n) {\n    class DefaultValue extends React.Component<P, { val?: {} }> {\n        constructor(props: P) {\n            super(props);\n            this.state = { val: updateDefault(props) };\n            this.notifyDefaultChange();\n        }\n        componentDidMount() {}\n        componentWillReceiveProps(nextProps: P) {\n            if (nextProps.status.state === undefined) {\n                this.setState({ val: updateDefault(nextProps) });\n            } else {\n                this.setState({ val: nextProps.value });\n            }\n        }\n        componentDidUpdate() {\n            this.notifyDefaultChange();\n        }\n        notifyDefaultChange() {\n            if (this.props.value !== this.state.val) {\n                this.props.dispatch(\n                    setDefaultValue,\n                    this.props.path,\n                    this.state.val\n                );\n            }\n        }\n        render() {\n            return <Comp {...this.props} value={this.state.val} />;\n        }\n    }\n\n    return DefaultValue;\n}\n\nexport default fromDefaultValue;\n","import * as React from 'react';\nimport { root, branch } from 'baobab-react/higher-order';\nimport createTree from '../Store/index';\nimport SchemaType from './SchemaType';\nimport validate from './../Utils/customValidator';\nimport { setValidationErrors } from '../Store/actions';\n\nimport { Schema } from '../../typings/types';\n\nconst BranchedSchemaType = branch(\n    {\n        schema: 'schema',\n        status: 'status',\n        value: 'value'\n    },\n    SchemaType\n);\n\nexport type Props = {\n    onChange: (value: {}, errors: {}[]) => void,\n    schema: Schema,\n    value?: {}\n};\nfunction noop() { };\n/**\n * Top Component\n */\nclass Container extends React.Component<Props, undefined> {\n    event: boolean;\n    static defaultProps = { schema: {} };\n    private tree: any;\n    private rooted: React.StatelessComponent<{\n        onChange: (value: {}, errors?: {}[]) => void,\n        path: string[]\n    }>;\n    props: Props;\n\n    constructor(props: Props) {\n        super(props);\n        this.tree = createTree();\n        this.updateTree(props.value, props.schema);\n        this.rooted = root(this.tree, BranchedSchemaType);\n    }\n    componentDidMount() {\n        this.tree\n            .select('value')\n            .on('update', (event: { data: { currentData: {} } }) => {\n                if (this.event) {\n                    this.props.onChange(\n                        event.data.currentData,\n                        validate(\n                            event.data.currentData,\n                            this.tree.get('schema'),\n                            event.data.currentData\n                        ).errors\n                    )\n                }\n            }\n            );\n    }\n\n    componentWillReceiveProps(nextProps: Props) {\n        if (\n            nextProps.value === this.tree.get('value') &&\n            nextProps.schema === this.props.schema\n        ) {\n            return;\n        }\n        this.updateTree(nextProps.value, nextProps.schema);\n    }\n    componentWillUnmount() {\n        this.tree.release();\n    }\n    shouldComponentUpdate() {\n        return false;\n    }\n    getValue() {\n        return this.tree.get('value');\n    }\n    updateTree(value?: {}, schema?: Schema) {\n        this.event = false;\n        this.tree.set('value', value);\n        this.tree.set('schema', schema);\n        this.tree.set('status', {});\n        this.tree.commit();\n        this.event = true;\n    }\n    validate() {\n        const validationResult = validate(\n            this.tree.get('value'),\n            this.tree.get('schema'),\n            this.tree.get('value')\n        );\n        setValidationErrors(this.tree, [], validationResult.errors);\n        return validationResult.errors;\n    }\n    render() {\n        const Rooted = this.rooted;\n        return <Rooted onChange={noop} path={[]} />;\n    }\n}\n\nexport default Container;\n","import Baobab from 'baobab';\n\nconst createTree = () => new Baobab({\n    schema: {},\n    value: {},\n    status: {}\n});\n\nexport default createTree;\n","import * as React from 'react';\nimport validator from '../Decorators/validator';\nimport { SimpleStringField } from './String';\nimport { Schema, Action } from '../../../typings/types';\n\ntype Props = {\n    schema: Schema & { type: 'number' | 'string' };\n    value?: number;\n    editKey: string;\n    path: string[];\n    dispatch: (action: Action, ...args: {}[]) => any;\n    onChange: (value: string | void | number) => void;\n};\n\nclass NumberField extends React.Component<Props, { value?: string | number }> {\n    boundChange: (value: number | string) => void;\n    props: Props;\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            value: props.value,\n        };\n        this.boundChange = this.onChange.bind(this);\n    }\n    componentWillReceiveProps(nextProps: Props) {\n        // if numerical values differ: update\n        if (Number(this.state.value) !== Number(nextProps.value)) {\n            this.setState({\n                value: nextProps.value,\n            });\n        }\n    }\n    onChange(val?: string | number) {\n        const value: string | number | undefined = val === '' ? undefined : val;\n        const numVal = Number(value);\n        this.setState(\n            {\n                value,\n            },\n            () => this.props.onChange(isNaN(numVal) ? value : numVal)\n        );\n    }\n    render() {\n        return (\n            <SimpleStringField\n                {...this.props}\n                value={this.state.value}\n                onChange={this.boundChange}\n            />\n        );\n    }\n}\n\nexport default validator(NumberField);\n","import ObjectField from './Object';\nimport StringField from './String';\nimport NumberField from './Number';\nimport BooleanField from './Boolean';\nimport ArrayField from './Array';\n\nexport default {\n    object: ObjectField,\n    string: StringField,\n    number: NumberField,\n    boolean: BooleanField,\n    array: ArrayField\n};\n","import * as React from 'react';\nimport Fields from './Fields/index';\nimport visible from './Decorators/visible';\nimport UndefinedField from './Fields/Undefined';\nimport inference from './Decorators/inference';\nimport fromDefaultValue from './Decorators/fromDefaultValue';\nimport { update } from '../Store/actions';\n\nimport { Schema, Action, TYPESTRING } from '../../typings/types';\n\ntype SchemaProps = {\n    schema: Schema;\n    status: { [key: string]: {} };\n    path: string[];\n    dispatch: (action: Action, ...args: {}[]) => any;\n    editKey?: string;\n    value?: {};\n};\n\n/**\n * Component generating the correct field based on schema.type\n * @constructor\n * @param {Object} props\n */\nclass SchemaType<P extends SchemaProps> extends React.Component<P> {\n    static defaultProps = {\n        path: [],\n    };\n    onChange: ({}) => void;\n    constructor(props: P) {\n        super(props);\n        this.onChange = (...args: {}[]) => {\n            props.dispatch(update, this.props.path, ...args);\n        };\n    }\n    render() {\n        const { schema: { type } } = this.props;\n        const renderType = Array.isArray(type)\n            ? (type as TYPESTRING[]).find(t => t !== 'null')\n            : type;\n        let Type: React.ComponentClass<any> | React.SFC<any>;\n        if (renderType === undefined || renderType === 'null') {\n            Type = UndefinedField;\n        } else {\n            Type = Fields[renderType];\n        }\n        if (Type === undefined) {\n            Type = UndefinedField;\n        }\n        return <Type {...this.props} onChange={this.onChange} />;\n    }\n}\n\nexport default inference(fromDefaultValue(visible(SchemaType)));\n"],"names":["type","React.createElement","DefaultWidget","undefinedWidgetFactory","obj","Object","assign","props","value","schema","view","forwardProps","children","editKey","path","onChange","onChildAdd","onChildRemove","addKey","removeKey","alterKey","errorMessage","Wdgt","defaultWidget","_Wdgt","renderType","Array","isArray","find","t","undefined","EMPTYOBJECT","formValue","customValidator","validate","tree","errors","errorPath","STATUS","concat","ERRORS","errorsCursor","select","length","get","splice","set","NO_ERRORS","errorMap","Map","forEach","error","property","push","message","key","split","filter","x","slice","statusPath","VALUE","STATE","Comp","dispatch","getErrors","val","validation","getFormValue","properties","index","mergedProperties","keys","v","sort","a","b","indexFor","i","prop","SchemaType","status","EMPTY_OBJECT","additionalProperties","babelHelpers.typeof","Error","newKey","p","Widget","map","e","oldValue","Number","defaultValue","items","String","onChildChange","visible","toString","currentPath","_React$Component","inferredSchema","infer","state","updatePath","_this","componentWillReceiveProps","nextProps","this","setState","render","React","updateDefault","notifyDefaultChange","componentDidMount","componentDidUpdate","setDefaultValue","createTree","Baobab","jsonschema","attributes","errored","instance","options","msg","validator","ObjectField","StringField","boundChange","bind","numVal","_this2","isNaN","SimpleStringField","NumberField","BooleanField","ArrayField","args","update","Type","UndefinedField","Fields","inference","fromDefaultValue","BranchedSchemaType","branch","updateTree","rooted","root","on","event","data","currentData","componentWillUnmount","release","shouldComponentUpdate","getValue","commit","validationResult","Rooted","noop","Container"],"mappings":"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"}