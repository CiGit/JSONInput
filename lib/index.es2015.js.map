{"version":3,"file":"index.es2015.js","sources":["../src/Store/index.ts","../src/Comps/Views/undefinedWidgetFactory.tsx","../src/Comps/Decorators/labeled.js","../src/Comps/Views/Input.js","../src/Comps/Views/TextWidget.js","../src/Comps/Views/ArrowNumberWidget.js","../src/Comps/Views/CheckboxWidget.js","../src/Comps/Views/ArrayWidget.js","../src/Comps/Views/ObjectWidget.js","../src/Comps/Views/SelectWidget.js","../src/Comps/Views/index.ts","../src/Comps/Views/Widget.tsx","../src/Utils/customValidator.ts","../src/Store/actions.ts","../src/Comps/Decorators/validator.tsx","../src/Comps/Fields/Object.tsx","../src/Comps/Fields/String.tsx","../src/Comps/Fields/Number.tsx","../src/Comps/Fields/Boolean.tsx","../src/Comps/Fields/Array.tsx","../src/Comps/Fields/index.tsx","../src/Comps/Decorators/visible.tsx","../src/Comps/Fields/Undefined.tsx","../src/Utils/infer.ts","../src/Comps/Decorators/inference.tsx","../src/Comps/Decorators/fromDefaultValue.tsx","../src/Comps/SchemaType.tsx","../src/Comps/Container.tsx"],"sourcesContent":["import Baobab from 'baobab';\n\nconst createTree = () => new Baobab({\n    schema: {},\n    value: {},\n    status: {}\n});\n\nexport default createTree;\n","import React from 'react';\n\nfunction undefinedWidgetFactory(\n    type: string\n) {\n    return function UndefinedWidget() {\n        return (\n            <span>\n                {`Widget for '${type}' was not defined`}\n            </span>\n        );\n    };\n}\n\nexport default undefinedWidgetFactory;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction labeled(Comp) {\n    function Label(props) {\n        const required = props.schema.required;\n        const requiredClassName = required ? 'required' : '';\n        return (\n            <div>\n                <label //eslint-disable-line\n                    className={`${props.schema.type}Field ${requiredClassName}`}\n                >\n                    <span className=\"title\">\n                        {props.view.title || props.editKey}\n                    </span>\n                    <Comp {...props} />\n                    <span>{props.view.description}</span>\n                    <span>{props.errorMessage}</span>\n                </label>\n            </div>\n        );\n    }\n\n    Label.propTypes = {\n        schema: PropTypes.shape({\n            type: PropTypes.oneOfType([\n                PropTypes.oneOf([\n                    'object',\n                    'string',\n                    'number',\n                    'array',\n                    'boolean'\n                ]),\n                PropTypes.arrayOf(\n                    PropTypes.oneOf([\n                        'object',\n                        'string',\n                        'number',\n                        'array',\n                        'boolean',\n                        'null'\n                    ])\n                )\n            ]).isRequired,\n            required: PropTypes.bool,\n            description: PropTypes.string\n        }).isRequired,\n        editKey: PropTypes.string,\n        view: PropTypes.shape({\n            title: PropTypes.string,\n            description: PropTypes.string\n        }).isRequired,\n        errorMessage: PropTypes.arrayOf(PropTypes.string)\n    };\n    Label.defaultProps = {\n        editKey: '',\n        errorMessage: []\n    };\n    return Label;\n}\n\nexport default labeled;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction onInputChange(func) {\n    return function onChange(event) {\n        if (event.target.type === 'checkbox') {\n            func(event.target.checked);\n        } else {\n            func(event.target.value);\n        }\n    };\n}\n\nfunction Input(props) {\n    return (\n        <input\n            type={props.type}\n            placeholder={props.schema.placeholder}\n            value={props.value || ''}\n            className={props.className}\n            onChange={onInputChange(props.onChange)}\n            checked={props.checked}\n        />\n    );\n}\n\nInput.propTypes = {\n    type: PropTypes.string.isRequired,\n    className: PropTypes.string,\n    onChange: PropTypes.func.isRequired,\n    checked: PropTypes.bool,\n    value: PropTypes.any, // eslint-disable-line\n    schema: PropTypes.shape({\n        placeholder: PropTypes.string\n    }).isRequired\n};\nInput.defaultProps = {\n    className: undefined,\n    checked: false\n};\nexport default Input;\n","import React from 'react';\nimport labeled from '../Decorators/labeled';\nimport Input from './Input';\n\nfunction TextWidget(props) {\n    return (\n        <Input\n            {...props}\n            type=\"string\"\n        />\n    );\n}\n\nexport default labeled(TextWidget);\n","import React from 'react';\nimport labeled from '../Decorators/labeled';\nimport Input from './Input';\n\nfunction ArrowNumberWidget(props) {\n    return (\n        <Input\n            {...props}\n            type=\"number\"\n        />\n    );\n}\n\nexport default labeled(ArrowNumberWidget);\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport labeled from '../Decorators/labeled';\nimport Input from './Input';\n\nfunction CheckboxWidget(props) {\n    return (\n        <Input\n            {...props}\n            type=\"checkbox\"\n            checked={props.value}\n        />\n    );\n}\n\nCheckboxWidget.propTypes = {\n    value: PropTypes.bool\n};\nCheckboxWidget.defaultProps = { value: false };\n\nexport default labeled(CheckboxWidget);\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport labeled from '../Decorators/labeled';\n\nfunction ArrayWidget(props) {\n    function renderChild(child, index) {\n        return (\n            <div>\n                <button\n                    onClick={function remove() {\n                        props.onChildRemove(index);\n                    }}\n                >\n                    -\n                </button>\n                {child}\n            </div>\n        );\n    }\n\n    const children = React.Children.map(props.children, renderChild);\n    return (\n        <div>\n            <div>\n                {children}\n            </div>\n            <button onClick={() => props.onChildAdd()}>+</button>\n        </div>\n    );\n}\n\nArrayWidget.propTypes = {\n    children: PropTypes.arrayOf(PropTypes.element).isRequired,\n    onChildRemove: PropTypes.func.isRequired, // eslint-disable-line react/no-unused-prop-types\n    onChildAdd: PropTypes.func.isRequired\n};\nexport default labeled(ArrayWidget);\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport labeled from '../Decorators/labeled';\n\nfunction ObjectWidget(props) {\n    return (\n        <div>\n            {props.children}\n        </div>\n    );\n}\n\nObjectWidget.propTypes = {\n    children: PropTypes.arrayOf(PropTypes.element).isRequired\n};\n\nexport default labeled(ObjectWidget);\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction SelectWidget(props) {\n    const { view, value, onChange } = props;\n    const choices = view.choices.map(c => (\n        <option key={c.value} value={c.value}>\n            {c.label}\n        </option>\n    ));\n    return (\n        <select value={value} onChange={e => onChange(e.target.value)}>\n            {choices}\n        </select>\n    );\n}\nSelectWidget.propTypes = {\n    view: PropTypes.shape({\n        choices: PropTypes.arrayOf(\n            PropTypes.shape({\n                value: PropTypes.any,\n                label: PropTypes.string.isRequired\n            })\n        ).isRequired\n    }).isRequired,\n    value: PropTypes.any, // eslint-disable-line\n    onChange: PropTypes.func.isRequired\n};\nexport default SelectWidget;\n","import React from 'react';\nimport undefinedWidgetFactory from './undefinedWidgetFactory';\nimport TextWidget from './TextWidget';\nimport ArrowNumberWidget from './ArrowNumberWidget';\nimport CheckboxWidget from './CheckboxWidget';\nimport ArrayWidget from './ArrayWidget';\nimport ObjectWidget from './ObjectWidget';\nimport SelectWidget from './SelectWidget';\n\nimport { WidgetProps } from '../../../typings/types';\n\nexport type WidgetMap = {\n    [key: string]: React.ComponentClass<WidgetProps> | React.SFC<WidgetProps>\n};\nlet DefaultWidget: WidgetMap = {\n    string: TextWidget,\n    number: TextWidget,\n    boolean: CheckboxWidget,\n    array: ArrayWidget,\n    object: ObjectWidget,\n    arrowNumber: ArrowNumberWidget,\n    select: SelectWidget\n};\n\nfunction defaultWidget(type: string) {\n    return DefaultWidget[type] || undefinedWidgetFactory(type);\n}\n\nfunction setDefaultWidgets(obj: WidgetMap) {\n    DefaultWidget = Object.assign({}, DefaultWidget, obj);\n}\n\nexport { defaultWidget, setDefaultWidgets, undefinedWidgetFactory };\n","import React from 'react';\nimport { defaultWidget } from './index';\n\nimport { WidgetProps, TYPESTRING } from '../../../typings/types';\n\ntype Props = WidgetProps & {\n    editKey: string,\n    path: string[],\n    children?: (React.ComponentClass<WidgetProps> | React.SFC<WidgetProps>)[],\n    addKey?: (key: string, value: {}) => void,\n    removeKey?: (key: string) => void,\n    alterKey?: (key: string, newKey: string) => void,\n    onChildAdd?: () => void,\n    onChildRemove?: (index: number) => void\n};\n\nconst EMPTYOBJECT = {};\nfunction Widget(props: Props) {\n    const {\n        value,\n        schema,\n        schema: { view },\n        children,\n        editKey,\n        path,\n        onChange,\n        onChildAdd,\n        onChildRemove,\n        addKey,\n        removeKey,\n        alterKey,\n        errorMessage,\n    } = props;\n    const forwardProps = {\n        value,\n        schema,\n        children,\n        editKey,\n        path,\n        onChange,\n        onChildAdd,\n        onChildRemove,\n        addKey,\n        removeKey,\n        alterKey,\n        errorMessage\n    };\n    if (view) {\n        const { type } = view;\n        if (typeof type === 'string') {\n            const Wdgt = defaultWidget(type);\n            return <Wdgt {...forwardProps} view={view} />;\n        }\n        if (typeof type === 'function') {\n            const Type = type;\n            return <Type {...forwardProps} view={view} />;\n        }\n    }\n    let renderType = Array.isArray(schema.type)\n        ? (schema.type as TYPESTRING[]).find(t => t !== 'null')\n        : schema.type;\n    let Wdgt;\n    if (renderType === undefined) {\n        Wdgt = defaultWidget('undefinedType');\n    } else {\n        Wdgt = defaultWidget(renderType)\n    }\n    return <Wdgt {...forwardProps} view={view || EMPTYOBJECT} />;\n}\n\nexport default Widget;\n","import jsonschema, { Validator } from 'jsonschema';\nimport { ValidatorResult } from \"jsonschema/lib\";\nimport { Schema, ErrorFn } from '../../typings/types';\n\nconst customValidator = new Validator();\ncustomValidator.attributes.errored = function validateErrored(\n    instance: {},\n    schema: { errored?: ErrorFn },\n    options: { formValue: {} }\n) {\n    if (typeof schema.errored !== 'function') {\n        throw new jsonschema.SchemaError('\"errored\" expects a function');\n    }\n    const msg = schema.errored(instance, options.formValue);\n    if (msg) {\n        return msg;\n    }\n    return undefined;\n};\nfunction validate(\n    value: {},\n    schema: Schema,\n    formValue: {}\n): ValidatorResult {\n    return customValidator.validate(value, schema, { formValue });\n}\n\nexport default validate;\n","/*\nEvery tree should be of type Baobab\n*/\nconst VALUE = 'value';\nconst STATUS = 'status';\nconst STATE = 'state';\nconst ERRORS = 'errors';\nconst NOERRORS: string[] = [];\n\nexport function setErrors(tree: any, path: string[], errors: string[]) {\n    const errorPath = [STATUS].concat(path).concat([ERRORS]);\n    const errorsCursor = tree.select(errorPath);\n    if (errors && errors.length && Array.isArray(errorsCursor.get())) {\n        errorsCursor.splice([0, errorsCursor.get().length]);\n        errorsCursor.concat(errors || []);\n    } else {\n        errorsCursor.set(errors || NOERRORS);\n    }\n}\n\n/**\n * Update a value in the tree\n *\n * @param {Baobab} tree the tree\n * @param {Array<string>} path path's value to update\n * @param value value to set\n * @param {Array<string>} errors errors relative to the value\n */\nexport function update(tree: any, path: string[], value: {}, errors: string[]) {\n    const statusPath = [STATUS].concat(path);\n    tree.set([VALUE].concat(path), value);\n    tree.set(statusPath.concat([STATE]), 'dirty');\n    setErrors(tree, path, errors);\n}\n\nexport function setDefaultValue(tree: any, path: string[], value: {}) {\n    tree.set([VALUE].concat(path), value);\n    tree.set([STATUS].concat(path).concat([STATE]), 'pristine');\n}\n\nexport function getStatus(tree: any, path: string[]) {\n    return tree.get([STATUS].concat(path).concat([STATE]));\n}\n\nexport function getErrors(tree: any, path: string[]) {\n    return tree.get([STATUS].concat(path).concat([ERRORS])) || NOERRORS;\n}\n\nexport function getFormValue(tree: any) {\n    return tree.get(VALUE);\n}\n/**\n * handle object's \"properties\" path and array's \"item\" path\n */\nfunction schemaPath(tree: any, path: string[]) {\n    return path.reduce((prev, val) => {\n        if (tree.get(prev).type === 'object') {\n            return prev.concat(['properties', val]);\n        } else if (tree.get(prev).type === 'array') {\n            return prev.concat(['items']);\n        }\n        return prev.concat([val]);\n    }, ['schema']);\n}\nexport function updateSchema(tree: any, path: string[], value: string[]) {\n    const updatedPath = schemaPath(tree, path);\n    tree.set(updatedPath, value);\n}\n\nexport function deleteSchema(tree: any, path: string[]) {\n    const updatedPath = schemaPath(tree, path);\n    tree.unset(updatedPath);\n}\n","import React from 'react';\nimport validate from './../../Utils/customValidator';\nimport { getFormValue, getErrors } from '../../Store/actions';\n\nimport { Schema, Action } from '../../../typings/types';\n\ntype Props = {\n    schema: Schema,\n    value?: {},\n    dispatch: (action: Action, ...args: {}[]) => any,\n    path: string[],\n    onChange: (value: {}, errors?: string[]) => void\n};\n\nfunction validated<P extends Props>(\n    Comp: React.ComponentClass<any> | React.SFC<any>\n) {\n    function Validator(props: P) {\n        function onChange(val: {}): void {\n            const validation = validate(\n                val,\n                props.schema,\n                props.dispatch(getFormValue)\n            );\n            const err = validation.errors.map(error => error.message);\n            props.onChange(val, err);\n        }\n        // console.log(getErrors);\n        return (\n            <Comp\n                {...props }\n                errorMessage={props.dispatch(getErrors, props.path)}\n                onChange={onChange}\n            />\n        );\n    }\n    return Validator;\n}\n\nexport default validated;\n","import React from 'react';\nimport SchemaType from '../SchemaType';\nimport Widget from '../Views/Widget';\nimport validator from '../Decorators/validator';\nimport { updateSchema, deleteSchema } from '../../Store/actions';\n\nimport { Schema, Action } from '../../../typings/types';\n\ntype Props = {\n    schema: Schema.Object,\n    status: { [key: string]: {} },\n    editKey: string,\n    value: {\n        [key: string]: {},\n    }\n    dispatch: (action: Action, ...args: {}[]) => any,\n    path: string[],\n    onChange: (value: {}) => void\n};\n\nconst EMPTY_OBJECT = {};\n\nfunction renderChildren(props: Props): JSX.Element[] {\n    const children = [];\n    const properties = props.schema.properties || {};\n    const value: { [key: string]: {} } = props.value || {};\n    // Holds schema properties and value properties missing from schema.\n    const mergedProperties: Array<string> = Object.keys(properties);\n\n    Object.keys(value).forEach(v => {\n        if (v in properties) {\n            return;\n        }\n        mergedProperties.push(v);\n    });\n    function indexFor(property: string): number {\n        if (\n            properties[property]\n        ) {\n            const index = properties[property].index;\n            if (typeof index === 'number') {\n                return index;\n            }\n        }\n        return 0;\n    }\n    // Index based sorting\n    function sortProperties(a: string, b: string): number {\n        return indexFor(a) - indexFor(b);\n    }\n\n    mergedProperties.sort(sortProperties);\n    for (let i: number = 0; i < mergedProperties.length; i += 1) {\n        const prop: string = mergedProperties[i];\n        if (prop in properties) {\n            children.push(\n                <SchemaType\n                    {...(props as any) }\n                    status={props.status[prop] || EMPTY_OBJECT}\n                    schema={properties[prop]}\n                    value={value[prop]}\n                    editKey={prop}\n                    key={prop}\n                />\n            );\n        } else {\n            const schema = props.schema.additionalProperties;\n            if (schema) {\n                props.dispatch(updateSchema, props.path.concat([prop]), schema);\n            }\n            children.push(\n                <SchemaType\n                    {...(props as any) }\n                    status={props.status[prop] || EMPTY_OBJECT}\n                    schema={schema}\n                    value={value[prop]}\n                    editKey={prop}\n                    key={prop}\n                />\n            );\n        }\n    }\n    return children;\n}\n\nfunction ObjectField(props: Props) {\n    function addKey(key: string, value: {}): void {\n        props.onChange(\n            Object.assign({}, props.value, {\n                [key]: value\n            })\n        );\n    }\n\n    function removeKey(key: string): void {\n        const value: { [key: string]: {} } = Object.assign({}, props.value);\n        delete value[key];\n        if (!(props.schema.properties && (key in props.schema.properties))) {\n            props.dispatch(deleteSchema, props.path.concat([key]), {});\n        }\n        props.onChange(value);\n    }\n\n    function alterKey(key: string, newKey: string): void {\n        const value: { [key: string]: {} } = {};\n        Object.keys(props.value).forEach(p => {\n            if (p !== key) {\n                value[p] = props.value[p];\n            } else {\n                value[newKey] = props.value[p];\n            }\n        });\n        props.onChange(value);\n    }\n    return (\n        <Widget\n            {...(props as any) }\n            addKey={addKey}\n            removeKey={removeKey}\n            alterKey={alterKey}\n        >\n            {renderChildren(props)}\n        </Widget>\n    );\n}\n\nexport default validator(ObjectField);\n","import React from 'react';\nimport Widget from '../Views/Widget';\nimport validator from '../Decorators/validator';\n\nimport { Schema, Action } from '../../../typings/types';\n\ntype Props = {\n    schema: Schema & { type: 'number' | 'string' },\n    value?: number | string,\n    editKey: string,\n    path: string[],\n    onChange: (value: string | number) => void,\n    dispatch: (action: Action, ...args: {}[]) => any,\n};\n\nfunction StringField(props: Props) {\n    const val = props.value !== undefined && props.value !== null\n        ? String(props.value)\n        : props.value;\n    return <Widget {...(props as any)} value={val} />;\n}\n\nexport { StringField as SimpleStringField };\nexport default validator(StringField);\n","import React from 'react';\nimport validator from '../Decorators/validator';\nimport { SimpleStringField } from './String';\nimport { Schema, Action } from '../../../typings/types';\n\ntype Props = {\n    schema: Schema & { type: 'number' | 'string' },\n    value?: number,\n    editKey: string,\n    path: string[],\n    dispatch: (action: Action, ...args: {}[]) => any,\n    onChange: (value: string | void | number) => void\n};\n\nclass NumberField\n    extends React.Component<Props, { value?: string | number }> {\n    boundChange: (value: number | string) => void;\n    props: Props;\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            value: props.value\n        };\n        this.boundChange = this.onChange.bind(this);\n    }\n    componentWillReceiveProps(nextProps: Props) {\n        // if numerical values differ: update\n        if (Number(this.state.value) !== Number(nextProps.value)) {\n            this.setState({\n                value: nextProps.value\n            });\n        }\n    }\n    onChange(val?: string | number) {\n        const value: string | number | undefined = val === '' ? undefined : val;\n        const numVal = Number(value);\n        this.setState(\n            {\n                value\n            },\n            () => this.props.onChange(isNaN(numVal) ? value : numVal)\n        );\n    }\n    render() {\n        return (\n            <SimpleStringField\n                {...(this.props as any)}\n                value={this.state.value}\n                onChange={this.boundChange}\n            />\n        );\n    }\n}\n\nexport default validator(NumberField);\n","import React from 'react';\nimport Widget from '../Views/Widget';\nimport validator from './../Decorators/validator';\n\nimport{ Schema, Action } from '../../../typings/types';\n\nfunction BooleanField(\n    props: {\n        schema: Schema & { type: 'boolean' },\n        editKey: string,\n        path: string[],\n        value: boolean,\n        onChange: (value: boolean) => void,\n        dispatch: (action: Action, ...args: {}[]) => any,\n    }\n) {\n    return <Widget {...(props as any)} />;\n}\n\nexport default validator(BooleanField);\n","import React from 'react';\nimport SchemaType from '../SchemaType';\nimport Widget from '../Views/Widget';\nimport validator from '../Decorators/validator';\n\nimport { Schema, Action } from '../../../typings/types';\n\ntype Props = {\n    onChange: (val: {}[]) => void,\n    schema: Schema & {\n        items?: Schema[] | Schema,\n        value?: {}[]\n    },\n    dispatch: (action: Action, ...args: {}[]) => any,\n    value?: {}[],\n    editKey: string,\n    status: { [key: string]: {} },\n    path: string[],\n    [key: string]: any\n};\nconst EMPTY_OBJECT = {};\n\nfunction onChildChange(index: number, props: Props) {\n    return function onChange(val: {}) {\n        const { value } = props;\n        if (value) {\n            props.onChange(\n                value.map((e, i) => {\n                    if (+i !== +index) {\n                        return e;\n                    }\n                    return val;\n                })\n            );\n        } else {\n            props.onChange([val]);\n        }\n    };\n}\n\nfunction onChildRemove(props: Props) {\n    return function onRemove(index: number) {\n        const oldValue = props.value || [];\n        props.onChange(oldValue.filter((e, i) => Number(i) !== Number(index)));\n    };\n}\n\nfunction onChildAdd(props: Props) {\n    return function onAdd(value?:{}) {\n        const oldValue = props.value || [];\n        props.onChange(oldValue.concat([value]));\n    };\n}\n\nfunction renderChildren(props: Props) {\n    const { value, schema: { value: defaultValue, items } } = props;\n    let valueItems: {}[];\n    if (value) {\n        valueItems = value;\n    } else if (defaultValue) {\n        valueItems = defaultValue as {}[];\n    } else {\n        valueItems = [];\n    }\n    const children: JSX.Element[] = [];\n    valueItems.forEach((val, i) =>\n        children.push(\n            <SchemaType\n                {...(props as any) }\n                schema={Array.isArray(items) ? items[i] || {} : items}\n                value={val}\n                editKey={String(i)}\n                status={props.status[String(i)] || EMPTY_OBJECT}\n                key={i}\n                onChange={onChildChange(i, props)}\n            />\n        )\n    );\n    return children;\n}\n\nfunction ArrayField(props: Props) {\n    return (\n        <Widget\n            {...(props as any) }\n            onChildAdd={onChildAdd(props)}\n            onChildRemove={onChildRemove(props)}\n        >\n            {renderChildren(props)}\n        </Widget>\n    );\n}\n\nexport default validator(ArrayField);\n","import ObjectField from './Object';\nimport StringField from './String';\nimport NumberField from './Number';\nimport BooleanField from './Boolean';\nimport ArrayField from './Array';\n\nexport default {\n    object: ObjectField,\n    string: StringField,\n    number: NumberField,\n    boolean: BooleanField,\n    array: ArrayField\n};\n","import React from 'react';\nimport { getFormValue } from '../../Store/actions';\nimport { Action, Schema } from '../../../typings/types';\n\ntype Props = {\n    schema: Schema,\n    path: string[],\n    value?: {},\n    dispatch: (action: Action, ...args: {}[]) => any\n};\nfunction visibility<P extends Props>(\n    Comp: React.ComponentClass<P> | React.SFC<P>\n): React.SFC<P> {\n    return function Visible(props: P) {\n        const { schema: { visible }, value } = props;\n        try {\n\n            if (visible && !visible(value, props.dispatch(getFormValue), props.path)) {\n                return null!;\n            }\n        } catch (e) { return null!; }\n        return <Comp {...props } />;\n    };\n}\n\nexport default visibility;\n","import React from 'react';\n\nimport { WidgetProps } from '../../../typings/types';\n\nfunction Undefined(props: WidgetProps) {\n    return (\n        <span>{`Undefined field type \"${props.schema.type.toString()}\", [${props.path.toString()}]`}</span>\n    );\n}\n\nexport default Undefined;\n","export default function infer(value?: {}) {\n    switch (typeof value) {\n        case 'number':\n            return 'number';\n        case 'string':\n            return 'string';\n        case 'boolean':\n            return 'boolean';\n        case 'object':\n            return Array.isArray(value) ? 'array' : 'object';\n        default:\n            return 'string';\n    }\n}\n","import React from 'react';\nimport infer from './../../Utils/infer';\nimport { Schema } from '../../../typings/types';\n/**\n * Update store's value path.\n * @param {Array<string>} currentValuePath the valuePath the parent\n * @param {string} editKey the key currently edited\n * @returns {Array<string>}the updated valuePath\n */\nfunction updatePath(currentPath: string[], editKey?: string): string[] {\n    if (editKey) {\n        return currentPath.concat([editKey]);\n    }\n    return currentPath;\n}\ntype Props = {\n    path: string[],\n    editKey?: string,\n    value?: {},\n    schema: Schema\n};\n\n/**\n * HOC, compute schema value from inferred type if schema is missing\n * @param {React.Component} Comp component to decorate.\n * @return {React.Component} the decorated component.\n */\nfunction inference<P extends Props>(\n    Comp: React.ComponentClass<P> | React.SFC<P>\n) {\n    class Infer extends React.Component<Props, { schema: Schema }> {\n        path: string[];\n        state: {\n            schema: Schema\n        };\n        constructor(props: Props) {\n            super(props);\n            const { schema } = props;\n            let inferedSchema = schema;\n            if (!inferedSchema || !('type' in inferedSchema)) {\n                inferedSchema = { type: infer(props.value) };\n            }\n            this.state = { schema: inferedSchema };\n            this.path = updatePath(this.props.path, this.props.editKey);\n        }\n        componentWillReceiveProps(nextProps: Props) {\n            if (this.props.schema !== nextProps.schema) {\n                let inferedSchema = nextProps.schema;\n                if (!inferedSchema || !('type' in inferedSchema)) {\n                    inferedSchema = { type: infer(nextProps.value) };\n                }\n                this.setState(() => ({ schema: inferedSchema }));\n            }\n        }\n        render() {\n            return (\n                <Comp {...(this.props as any) } path={this.path} schema={this.state.schema} />\n            );\n        }\n    }\n    return Infer;\n}\n\nexport default inference;\n","import React from 'react';\nimport { setDefaultValue } from '../../Store/actions';\nimport { Action, Schema } from '../../../typings/types';\n\nexport type Props = {\n    editKey?: string,\n    path: string[],\n    value?: {},\n    schema: Schema,\n    dispatch: (action: Action, ...args: ({} | void)[]) => any\n};\nfunction updateDefault({ value, schema: { value: defaultValue } }: Props) {\n    const val = value !== undefined ? value : defaultValue;\n    return val;\n}\n\nfunction fromDefaultValue<P extends Props>(\n    Comp: React.ComponentClass<P> | React.SFC<P>\n) {\n    class DefaultValue extends React.Component<Props, { val?: {} }> {\n        constructor(props: Props) {\n            super(props);\n            this.state = { val: updateDefault(props) };\n            this.notifyDefaultChange();\n        }\n        componentDidMount() {\n        }\n        componentWillReceiveProps(nextProps: Props) {\n            if (nextProps.schema !== this.props.schema) {\n                this.setState({ val: updateDefault(nextProps) });\n            } else {\n                this.setState({ val: nextProps.value });\n            }\n        }\n        componentDidUpdate() {\n            this.notifyDefaultChange();\n        }\n        notifyDefaultChange() {\n            if (this.props.value !== this.state.val) {\n                this.props.dispatch(\n                    setDefaultValue,\n                    this.props.path,\n                    this.state.val\n                );\n            }\n        }\n        render() {\n            return <Comp {...(this.props as any) } value={this.state.val} />;\n        }\n    }\n\n    return DefaultValue;\n}\n\nexport default fromDefaultValue;\n","import React from 'react';\nimport Fields from './Fields/index';\nimport visible from './Decorators/visible';\nimport UndefinedField from './Fields/Undefined';\nimport inference from './Decorators/inference';\nimport fromDefaultValue from './Decorators/fromDefaultValue';\nimport { update } from '../Store/actions';\n\nimport { Schema, Action, TYPESTRING } from '../../typings/types';\n\ntype SchemaProps = {\n    schema: Schema,\n    status: { [key: string]: {} },\n    path: string[],\n    dispatch: (action: Action, ...args: {}[]) => any,\n    editKey?: string,\n    value?: {}\n};\n\n/**\n * Component generating the correct field based on schema.type\n * @constructor\n * @param {Object} props\n */\nclass SchemaType extends React.Component<SchemaProps, undefined> {\n    static defaultProps = {\n        path: []\n    };\n    onChange: ({ }) => void;\n    constructor(props: SchemaProps) {\n        super(props);\n        this.onChange = function onChange(...args: {}[]) {\n            props.dispatch(update, props.path, ...args);\n        };\n    }\n    render() {\n        const { schema: { type } } = this.props;\n        const renderType = Array.isArray(type)\n            ? (type as TYPESTRING[]).find(t => t !== 'null')\n            : type;\n        let Type: React.ComponentClass<any> | React.SFC<any>;\n        if (renderType === undefined || renderType === 'null') {\n            Type = UndefinedField;\n        } else {\n            Type = Fields[renderType];\n        }\n        return <Type {...this.props} onChange={this.onChange} />;\n    }\n}\n\nexport default inference(fromDefaultValue(visible(SchemaType)));\n","import React from 'react';\nimport { root, branch } from 'baobab-react/higher-order';\nimport createTree from '../Store/index';\nimport SchemaType from './SchemaType';\nimport { setErrors } from '../Store/actions';\nimport validate from './../Utils/customValidator';\n\nimport { Schema } from '../../typings/types';\n\nconst BranchedSchemaType = branch(\n    {\n        schema: 'schema',\n        status: 'status',\n        value: 'value'\n    },\n    SchemaType\n);\n\nexport type Props = {\n    onChange: (value: {}, errors: {}[]) => void,\n    schema: Schema,\n    value?: {}\n};\nfunction noop() { };\n/**\n * Top Component\n */\nclass Container extends React.Component<Props, undefined> {\n    event: boolean;\n    static defaultProps = { schema: {} };\n    private tree: any;\n    private rooted: React.StatelessComponent<{\n        onChange: (value: {}, errors?: {}[]) => void,\n        path: string[]\n    }>;\n    props: Props;\n\n    constructor(props: Props) {\n        super(props);\n        this.tree = createTree();\n        this.updateTree(props.value, props.schema);\n        this.rooted = root(this.tree, BranchedSchemaType);\n    }\n    componentDidMount() {\n        this.tree\n            .select('value')\n            .on('update', (event: { data: { currentData: {} } }) => {\n                if (this.event) {\n                    this.props.onChange(\n                        event.data.currentData,\n                        validate(\n                            event.data.currentData,\n                            this.tree.get('schema'),\n                            event.data.currentData\n                        ).errors\n                    )\n                }\n            }\n            );\n    }\n\n    componentWillReceiveProps(nextProps: Props) {\n        if (\n            nextProps.value === this.tree.get('value') &&\n            nextProps.schema === this.props.schema\n        ) {\n            return;\n        }\n        this.updateTree(nextProps.value, nextProps.schema);\n    }\n    componentWillUnmount() {\n        this.tree.release();\n    }\n    shouldComponentUpdate() {\n        return false;\n    }\n    getValue() {\n        return this.tree.get('value');\n    }\n    updateTree(value?: {}, schema?: Schema) {\n        this.event = false;\n        this.tree.set('value', value);\n        this.tree.set('schema', schema);\n        this.tree.set('status', {});\n        this.tree.commit();\n        this.event = true;\n    }\n    validate() {\n        const validationResult = validate(\n            this.tree.get('value'),\n            this.tree.get('schema'),\n            this.tree.get('value')\n        );\n        const errorMap = new Map<string, string[]>();\n        // Collect each error associated with a given path\n        validationResult.errors.forEach(error => {\n            const errors = errorMap.get(error.property) || [];\n            errors.push(error.message); // Add new error\n            errorMap.set(error.property, errors);\n        });\n        errorMap.forEach((value, key) => {\n            setErrors(\n                this.tree,\n                key.split(/\\.|\\[|\\]/).filter(x => x !== '').slice(1),\n                value\n            );\n        });\n        return validationResult.errors;\n    }\n    render() {\n        const Rooted = this.rooted;\n        return <Rooted onChange={noop} path={[]} />;\n    }\n}\n\nexport default Container;\n"],"names":["schema","value","status","required","React","className","type","view","title","editKey","description","errorMessage","defaultProps","target","checked","placeholder","onChange","onInputChange","Input","TextWidget","ArrowNumberWidget","CheckboxWidget","Children","map","children","onClick","onChildRemove","onChildAdd","ArrayWidget","ObjectWidget","choices","key","label","string","number","boolean","array","object","arrowNumber","select","SelectWidget","undefinedWidgetFactory","DefaultWidget","Object","assign","path","addKey","removeKey","alterKey","defaultWidget","Array","isArray","find","EMPTYOBJECT","customValidator","attributes","errored","SchemaError","formValue","validate","STATUS","STATE","ERRORS","NOERRORS","concat","length","get","splice","set","VALUE","setErrors","reduce","schemaPath","unset","dispatch","getErrors","getFormValue","errors","message","index","properties","keys","forEach","push","sort","SchemaType","EMPTY_OBJECT","additionalProperties","updateSchema","Widget","deleteSchema","renderChildren","ObjectField","StringField","state","boundChange","bind","componentWillReceiveProps","setState","props","isNaN","render","SimpleStringField","Component","NumberField","BooleanField","filter","items","onChildChange","ArrayField","visible","toString","infer","updatePath","val","updateDefault","notifyDefaultChange","componentDidMount","componentDidUpdate","setDefaultValue","update","UndefinedField","Fields","fromDefaultValue","branch","tree","createTree","updateTree","rooted","root","BranchedSchemaType","on","event","data","currentData","componentWillUnmount","release","shouldComponentUpdate","getValue","commit","property","split","slice","noop","Container"],"mappings":"uLAEA,eAAmB,6BAAiB,CAChCA,SADgC,CAEhCC,QAFgC,CAGhCC,SAHgC,EAApC,CAAA,CCAA,+BAAA,IAGI,kBACI,8EAMP,CAED,CCXA,gBAAA,GAAuB,CACnB,aAAsB,CAClB,MAAiB,EAAMF,MAAN,CAAaG,QAA9B,CACM,EAAoB,EAAW,UAAX,CAAwB,EADlD,CAEA,sCAEQC,mBAAA,QAAA,EACIC,UAAc,EAAML,MAAN,CAAaM,IAAb,SAAA,GADlB,CAGIF,mBAAA,OAAA,EAAMC,UAAU,QAAhB,CACK,EAAME,IAAN,CAAWC,KAAX,EAAoB,EAAMC,OAD/B,CAHJ,CAMIL,mBAAA,KANJ,CAOIA,mBAAA,OAAA,KAAA,CAAO,EAAMG,IAAN,CAAWG,WAAlB,CAPJ,CAQIN,mBAAA,OAAA,KAAA,CAAO,EAAMO,YAAb,CARJ,EAiDZ,UAJMC,aAAe,CACjBH,QAAS,EADQ,CAEjBE,eAFiB,GAOzB,CC1DA,sBAAA,GAA6B,CACzB,kBAAgC,CACF,eAAhBE,OAAOP,IAAS,CACtB,EAAK,EAAMO,MAAN,CAAaC,OAAlB,CADsB,CAGtB,EAAK,EAAMD,MAAN,CAAaZ,KAAlB,CAGX,CAED,eAAA,GAAsB,CAClB,oCAEQK,KAAM,EAAMA,KACZS,YAAa,EAAMf,MAAN,CAAae,YAC1Bd,MAAO,EAAMA,KAAN,EAAe,GACtBI,UAAW,EAAMA,UACjBW,SAAUC,cAAc,EAAMD,QAApBC,EACVH,QAAS,EAAMA,SAe3BI,OAAMN,YAANM,CAAqB,CACjBb,gBADiB,CAEjBS,UAFiB,++BChCrB,mBAAA,GAA2B,CACvB,2BACKI,qBAEGZ,KAAK,WAKjB,0BAAuBa,WAAvB,CCTA,0BAAA,GAAkC,CAC9B,2BACKD,qBAEGZ,KAAK,WAKjB,iCAAuBc,kBAAvB,CCRA,uBAAA,GAA+B,CAC3B,2BACKF,qBAEGZ,KAAK,WACLQ,QAAS,EAAMb,QAQ3BoB,gBAAeT,YAAfS,CAA8B,CAAEpB,QAAF,EAE9B,6BAAuBoB,eAAvB,CChBA,oBAAA,GAA4B,CAgBxB,MAAiBjB,MAAMkB,QAANlB,CAAemB,GAAfnB,CAAmB,EAAMoB,QAAzBpB,CAfjB,aAAmC,CAC/B,sCAEQA,mBAAA,SAAA,EACIqB,QAAS,UAAkB,CACvB,EAAMC,aAAN,GAFR,EAAA,IAAA,IAYK,CAAAtB,CAAjB,CACA,sCAEQA,mBAAA,MAAA,KAAA,IAGAA,mBAAA,SAAA,EAAQqB,QAAS,oBAAYE,YAA7B,EAAA,IAAA,EAUZ,2BAAuBC,YAAvB,CChCA,qBAAA,GAA6B,CACzB,sCAES,EAAMJ,SASnB,4BAAuBK,aAAvB,CCbA,qBAAA,GAA6B,SACjBtB,SAAMN,UAAOe,SACf,EAAU,EAAKc,OAAL,CAAaP,GAAb,CAAiB,iDACrBQ,IAAK,EAAE9B,MAAOA,MAAO,EAAEA,OAC1B,EAAE+B,MAFK,CAAA,EAKhB,qCACY/B,QAAce,SAAU,qBAAc,EAAEH,MAAF,CAASZ,MAAvD,KAiBR,CCdA,kBAA+B,CAC3BgC,OAAQd,YADmB,CAE3Be,OAAQf,YAFmB,CAG3BgB,QAASd,gBAHkB,CAI3Be,MAAOR,aAJoB,CAK3BS,OAAQR,cALmB,CAM3BS,YAAalB,mBANc,CAO3BmB,OAAQC,YAPmB,CAA/B,CAUA,sBAAA,IACI,yBAA8BC,yBAGlC,2BAAA,IACIC,cAAgBC,OAAOC,MAAPD,IAAkBD,aAAlBC,GAGpB,CChBA,kBAAA,CACA,eAAA,YAEQ1C,UACAD,WACAA,OAAUO,SACViB,aACAf,YACAoC,SACA7B,aACAW,eACAD,kBACAoB,WACAC,cACAC,aACArC,aAEE,EAAe,CACjBV,OADiB,CAEjBD,QAFiB,CAGjBwB,UAHiB,CAIjBf,SAJiB,CAKjBoC,MALiB,CAMjB7B,UANiB,CAOjBW,YAPiB,CAQjBD,eARiB,CASjBoB,QATiB,CAUjBC,WAViB,CAWjBC,UAXiB,CAYjBrC,cAZiB,EAcrB,KAAU,SACEL,KACR,GAAoB,kBAApB,CAA8B,CAC1B,MAAa2C,gBAAb,CACA,4CAA+B1C,SAEnC,IAAoB,oBAApB,CAEI,4CAA+BA,SAGvC,MAAA,CAAI,EAAa2C,MAAMC,OAAND,CAAc,EAAO5C,IAArB4C,EACV,EAAO5C,IAAP,CAA6B8C,IAA7B,CAAkC,kBAAW,UAA7C,CAAA,CADUF,CAEX,EAAO5C,IAFb,CASA,SALI,MAAA,KACO2C,cAAc,eAAdA,CADP,CAGOA,iBAEJ7C,mBAAA,kBAAwBG,KAAM,GAAQ8C,aAAtC,CAGX,CClEA,oBAAwB,aAAxB,CACAC,gBAAgBC,UAAhBD,CAA2BE,OAA3BF,CAAqC,gBAKjC,GAA8B,qBAAZE,OAAlB,CACI,qBAAqBC,YAAY,+BAAjC,CAEJ,MAAY,EAAOD,OAAP,GAAyB,EAAQE,SAAjC,CAAZ,oBAMJ,iBAAA,QAKI,uBAAuBC,aAAwB,CAAED,WAAF,EAGnD,CCxBA,UAAc,OAAd,CACME,OAAS,QADf,CAEMC,MAAQ,OAFd,CAGMC,OAAS,QAHf,CAIMC,WAJN,CAMA,kBAAA,QACI,MAAkB,CAACH,MAAD,EAASI,MAAT,IAAsBA,MAAtB,CAA6B,CAACF,MAAD,CAA7B,CAAlB,CACM,EAAe,EAAKvB,MAAL,GADrB,CAEI,GAAU,EAAO0B,MAAjB,EAA2Bf,MAAMC,OAAND,CAAc,EAAagB,GAAb,EAAdhB,CAA3B,EACA,EAAaiB,MAAb,CAAoB,CAAC,CAAD,CAAI,EAAaD,GAAb,GAAmBD,MAAvB,CAApB,EACA,EAAaD,MAAb,CAAoB,KAApB,CAFA,EAIA,EAAaI,GAAb,CAAiB,GAAUL,QAA3B,CAYR,gBAAA,UACI,MAAmB,CAACH,MAAD,EAASI,MAAT,GAAnB,CACA,EAAKI,GAAL,CAAS,CAACC,KAAD,EAAQL,MAAR,GAAT,IACA,EAAKI,GAAL,CAAS,EAAWJ,MAAX,CAAkB,CAACH,KAAD,CAAlB,CAAT,CAAqC,OAArC,CADA,CAEAS,gBAGJ,yBAAA,QACI,EAAKF,GAAL,CAAS,CAACC,KAAD,EAAQL,MAAR,GAAT,IACA,EAAKI,GAAL,CAAS,CAACR,MAAD,EAASI,MAAT,IAAsBA,MAAtB,CAA6B,CAACH,KAAD,CAA7B,CAAT,CAAgD,UAAhD,CAGJ,mBAAA,MAKI,SAAYK,IAAI,CAACN,MAAD,EAASI,MAAT,IAAsBA,MAAtB,CAA6B,CAACF,MAAD,CAA7B,IAA2CC,QAG/D,sBAAA,IACI,SAAYG,IAAIG,MAKpB,oBAAA,MACI,SAAYE,OAAO,oBACa,aAAnBL,OAAU5D,OACH0D,OAAO,CAAC,YAAD,KACY,YAAnBE,OAAU5D,IAAS,CACxB,EAAK0D,MAAL,WADwB,CAG5B,EAAKA,MAAL,CAAY,GAAZ,CANJ,aASX,sBAAA,QACI,MAAoBQ,eAApB,CACA,EAAKJ,GAAL,KAGJ,sBAAA,MACI,MAAoBI,eAApB,CACA,EAAKC,KAAL,ICzDJ,oBAAA,IAsBI,mBARI,4CAGQ9D,aAAc,EAAM+D,QAAN,CAAeC,SAAf,CAA0B,EAAM9B,IAAhC,EACd7B,SAdR,YACI,MAAmB2C,WAEf,EAAM3D,MAFS2D,CAGf,EAAMe,QAAN,CAAeE,YAAf,CAHejB,CAAnB,CAKM,EAAM,EAAWkB,MAAX,CAAkBtD,GAAlB,CAAsB,qBAAeuD,OAArC,CAAA,CALZ,CAMA,EAAM9D,QAAN,KAIA,IAQX,CAED,CCnBA,mBAAA,CAEA,uBAAA,IAaI,cACI,GACI,IADJ,CAEE,CACE,MAAc,KAAqB+D,KAAnC,CACA,GAAqB,kBAArB,CACI,QAGR,SArBJ,SAAA,CACM,EAAa,EAAM/E,MAAN,CAAagF,UAAb,IADnB,CAEM,EAA+B,EAAM/E,KAAN,IAFrC,CAIM,EAAkC0C,OAAOsC,IAAPtC,GAJxC,CAMAA,OAAOsC,IAAPtC,IAAmBuC,OAAnBvC,CAA2B,YACnB,QAGJ,EAAiBwC,IAAjB,GAJJ,CAAAxC,EAsBA,EAAiByC,IAAjB,CAJA,cACI,YAAqB,IAGzB,CAAA,EACA,IAAK,KAAA,CAAI,EAAY,CAArB,CAAwB,EAAI,EAAiBnB,MAA7C,CAAqD,GAAK,CAA1D,CAEI,KADqB,KACjB,MAAJ,CACI,EAASkB,IAAT,CACI/E,mBAAA,CAACiF,YAAD,gBAEInF,OAAQ,EAAMA,MAAN,KAAsBoF,aAC9BtF,OAAQ,KACRC,MAAO,KACPQ,UACAsB,OANJ,CADJ,EADJ,IAWO,CACH,MAAe,EAAM/B,MAAN,CAAauF,oBAA5B,CADG,GAGC,EAAMb,QAAN,CAAec,YAAf,CAA6B,EAAM3C,IAAN,CAAWmB,MAAX,CAAkB,GAAlB,CAA7B,GAHD,CAKH,EAASmB,IAAT,CACI/E,mBAAA,CAACiF,YAAD,gBAEInF,OAAQ,EAAMA,MAAN,KAAsBoF,aAC9BtF,SACAC,MAAO,KACPQ,UACAsB,OANJ,CADJ,CAYR,SAGJ,qBAAA,IA6BI,2BACK0D,sBAEG3C,OA/BR,oBACI,EAAM9B,QAAN,CACI2B,OAAOC,MAAPD,IAAkB,EAAM1C,KAAxB0C,eAAAA,EADJ,CA4BA,EAGII,UAxBR,YACI,MAAqCJ,OAAOC,MAAPD,IAAkB,EAAM1C,KAAxB0C,CAArC,CACA,WAAA,CACM,EAAM3C,MAAN,CAAagF,UAAb,EAA4B,OAAahF,OAAOgF,UAAhD,EACF,EAAMN,QAAN,CAAegB,YAAf,CAA6B,EAAM7C,IAAN,CAAWmB,MAAX,CAAkB,GAAlB,CAA7B,IAFJ,CAIA,EAAMhD,QAAN,GAeA,EAIIgC,SAhBR,cACI,QAAA,CACAL,OAAOsC,IAAPtC,CAAY,EAAM1C,KAAlB0C,EAAyBuC,OAAzBvC,CAAiC,YACzB,MAGA,KAAgB,EAAM1C,KAAN,GAHhB,CACA,KAAW,EAAMA,KAAN,GAFnB,CAAA0C,EAOA,EAAM3B,QAAN,GAGA,IAMK2E,kBAKb,+BAAyBC,YAAzB,CC/GA,oBAAA,IACI,YAAY,KAAM3F,KAAN,EAA6C,SAAVA,KAAnC,CACC,EAAMA,KAAN,GADD,CAEN,EAAMA,KAFZ,CAGA,2BAAQwF,sBAA2BxF,UAGvC,+BACyB4F,YADzB,yBCJI,0EACI,MAAA,KAAA,cACKC,MAAQ,CACT7F,MAAO,EAAMA,KADJ,EAGb,EAAK8F,WAAL,CAAmB,EAAK/E,QAAL,CAAcgF,IAAd,uCAEvBC,sCAEQ,CAAO,KAAKH,KAAL,CAAW7F,KAAlB,GAAoC,EAAUA,KAA9C,EACA,KAAKiG,QAAL,CAAc,CACVjG,MAAO,EAAUA,KADP,CAAd,eAKRe,gCACU,EAA6C,aAAA,GAC7C,KACN,KAAKkF,QAAL,CACI,CACIjG,OADJ,CADJ,CAII,oBAAWkG,MAAMnF,SAASoF,aAJ9B,CAAA,eAOJC,kBACI,2BACKC,wBACQ,KAAKH,OACVlG,MAAO,KAAK6F,KAAL,CAAW7F,MAClBe,SAAU,KAAK+E,mBAjCnB3F,MAAMmG,UDOlB,2BCgCyBC,YDhCzB,CEhBA,qBAAA,IAUI,2BAAQf,SAGZ,gCAAyBgB,aAAzB,kBAAA,CCGA,sBAAA,MACI,2BACYxG,QAEJ,EAAMe,QAAN,CACI,EAAMO,GAAN,CAAU,oBACF,IAAO,EAAP,IADR,CAAA,CADJ,EASA,EAAMP,QAAN,CAAe,GAAf,CAGX,CAED,uBAAA,IACI,mBACI,MAAiB,EAAMf,KAAN,IAAjB,CACA,EAAMe,QAAN,CAAe,EAAS0F,MAAT,CAAgB,oBAAU,MAA1B,CAAA,CAAf,CAEP,CAED,oBAAA,IACI,mBACI,MAAiB,EAAMzG,KAAN,IAAjB,CACA,EAAMe,QAAN,CAAe,EAASgD,MAAT,CAAgB,GAAhB,CAAf,CAEP,CAED,0BAAA,OAEQ,OADI/D,UAAOD,WAAUC,UAAqB0G,mBAS9C,QAAA,CAcA,SAbWzB,QAAQ,uBACNC,KACL/E,mBAAA,CAACiF,YAAD,gBAEIrF,OAAQkD,MAAMC,OAAND,IAAuB,QAAvBA,GACRjD,QACAQ,aACAP,OAAQ,EAAMA,MAAN,KAAA,GAA2BoF,eACnCvD,MACAf,SAAU4F,oBAPd,EAFR,IAgBJ,oBAAA,IACI,2BACKnB,sBAEG9D,WAAYA,cACZD,cAAeA,mBAEdiE,oBAKb,8BAAyBkB,WAAzB,QCvFe,CACXxE,OAAQuD,aADG,CAEX3D,OAAQ4D,aAFG,CAGX3D,OAAQsE,aAHG,CAIXrE,QAASsE,cAJE,CAKXrE,MAAOyE,YALI,CDuFf,CEnFA,qBAAA,IAGI,2BACY7G,OAAU8G,YAAW7G,MAC7B,GAAI,CAEA,GAAI,GAAW,CAAC,IAAe,EAAMyE,QAAN,CAAeE,YAAf,CAAf,CAA6C,EAAM/B,IAAnD,CAAhB,CACI,WAEN,SAAU,CAAE,WACd,gCAEP,CAED,CCrBA,kBAAA,IACI,gEACoC,EAAM7C,MAAN,CAAaM,IAAb,CAAkByG,QAAlB,UAAmC,EAAMlE,IAAN,CAAWkE,QAAX,OAI3E,mBCTI,mDAAA,EACI,IAAK,QAAL,CACI,MAAO,QAAP,CACJ,IAAK,QAAL,CACI,MAAO,QAAP,CACJ,IAAK,SAAL,CACI,MAAO,SAAP,CACJ,IAAK,QAAL,CACI,aAAa5D,WAAiB,QAAU,QAAxC,CACJ,QACI,MAAO,QAAP,CAVR,ECQJ,mBAAA,eAEe,EAAYa,MAAZ,CAAmB,GAAnB,GAgBf,mBAAA,sBAQQ,0EACI,MAAA,KAAA,SACQhE,OACJ,cACoB,aACpB,EAAgB,CAAEM,KAAM0G,MAAM,EAAM/G,KAAZ+G,CAAR,GAEpB,EAAKlB,KAAL,CAAa,CAAE9F,QAAF,EACb,EAAK6C,IAAL,CAAYoE,WAAW,EAAKd,KAAL,CAAWtD,IAAtBoE,CAA4B,EAAKd,KAAL,CAAW1F,OAAvCwG,qCAEhBhB,sCACI,GAAI,KAAKE,KAAL,CAAWnG,MAAX,GAAsB,EAAUA,MAApC,CAA4C,CACxC,MAAoB,EAAUA,MAA9B,CACI,GAAoB,UAApB,GACA,EAAgB,CAAEM,KAAM0G,MAAM,EAAU/G,KAAhB+G,CAAR,CADhB,EAGJ,KAAKd,QAAL,CAAc,iBAAO,CAAElG,QAAF,CAArB,CAAA,CAEP,eACDqG,kBACI,yCACe,KAAKF,OAAgBtD,KAAM,KAAKA,KAAM7C,OAAQ,KAAK8F,KAAL,CAAW9F,cA1B5DI,MAAMmG,WA8B1B,QAGJ,CCpDA,sBAAA,YAAyBtG,UAAOD,OAAUC,MAChC,QAAM,SACZ,QAGJ,0BAAA,sBAIQ,0EACI,MAAA,KAAA,cACK6F,MAAQ,CAAEoB,IAAKC,gBAAP,EACb,EAAKC,mBAAL,sCAEJC,2CAEApB,sCACQ,EAAUjG,MAAV,GAAqB,KAAKmG,KAAL,CAAWnG,MAAhC,CAGA,KAAKkG,QAAL,CAAc,CAAEgB,IAAK,EAAUjH,KAAjB,CAAd,CAHA,CACA,KAAKiG,QAAL,CAAc,CAAEgB,IAAKC,gBAAP,CAAd,eAKRG,8BACI,KAAKF,mBAAL,gBAEJA,+BACQ,KAAKjB,KAAL,CAAWlG,KAAX,GAAqB,KAAK6F,KAAL,CAAWoB,GAAhC,EACA,KAAKf,KAAL,CAAWzB,QAAX,CACI6C,eADJ,CAEI,KAAKpB,KAAL,CAAWtD,IAFf,CAGI,KAAKiD,KAAL,CAAWoB,GAHf,eAORb,kBACI,yCAAkB,KAAKF,OAAgBlG,MAAO,KAAK6F,KAAL,CAAWoB,WA5BtC9G,MAAMmG,WAgCjC,QAGJ,4BCzBI,0EACI,MAAA,KAAA,cACKvF,SAAW,+EACZ,EAAM0D,QAAN,MAAA,IAAe8C,OAAQ,EAAM3E,eAA7B,sCAGRwD,qBAKQ,KAJyB,KAAKF,KAAL,CAArBnG,MAAqB,CAAXM,KACZ,EAAa4C,MAAMC,OAAND,IACZ,EAAsBE,IAAtB,CAA2B,kBAAW,UAAtC,CAAA,CADYF,GASnB,SALI,MAAA,MAA2C,UAA3C,CACOuE,SADP,CAGOC,UAEJtH,mBAAA,eAAU,KAAK+F,OAAOnF,SAAU,KAAKA,UAArC,MAtBUZ,MAAMmG,WACpBlB,uBAAAA,CAAe,CAClBxC,OADkB,EAyB1B,2BAAyB8E,iBAAiBb,aAAQzB,UAARyB,CAAjBa,EAAzB,oBCzC2BC,OACvB,CACI5H,OAAQ,QADZ,CAEIE,OAAQ,QAFZ,CAGID,MAAO,OAHX,CADuB2H,CAMvBvC,YANuBuC,CDyC3B,CC3BA,aAAA,gCAcI,0EACI,MAAA,KAAA,cACKC,KAAOC,aACZ,EAAKC,UAAL,CAAgB,EAAM9H,KAAtB,CAA6B,EAAMD,MAAnC,EACA,EAAKgI,MAAL,CAAcC,KAAK,EAAKJ,IAAVI,CAAgBC,kBAAhBD,qCAElBZ,wCACI,KAAKQ,IAAL,CACKtF,MADL,CACY,OADZ,EAEK4F,EAFL,CAEQ,QAFR,CAEkB,YACN,EAAKC,KAAL,EACA,EAAKjC,KAAL,CAAWnF,QAAX,CACI,EAAMqH,IAAN,CAAWC,WADf,CAEI3E,SACI,EAAM0E,IAAN,CAAWC,WADf3E,CAEI,EAAKkE,IAAL,CAAU3D,GAAV,CAAc,QAAd,CAFJP,CAGI,EAAM0E,IAAN,CAAWC,WAHf3E,EAIEkB,MANN,CAJZ,CAAA,eAiBJoB,sCAEQ,EAAUhG,KAAV,GAAoB,KAAK4H,IAAL,CAAU3D,GAAV,CAAc,OAAd,CAApB,EACA,EAAUlE,MAAV,GAAqB,KAAKmG,KAAL,CAAWnG,MADhC,EAKJ,KAAK+H,UAAL,CAAgB,EAAU9H,KAA1B,CAAiC,EAAUD,MAA3C,eAEJuI,gCACI,KAAKV,IAAL,CAAUW,OAAV,gBAEJC,iCACI,sBAEJC,oBACI,YAAYb,KAAK3D,IAAI,sBAEzB6D,yBACI,KAAKK,KAAL,GAAA,CACA,KAAKP,IAAL,CAAUzD,GAAV,CAAc,OAAd,GADA,CAEA,KAAKyD,IAAL,CAAUzD,GAAV,CAAc,QAAd,GAFA,CAGA,KAAKyD,IAAL,CAAUzD,GAAV,CAAc,QAAd,IAHA,CAIA,KAAKyD,IAAL,CAAUc,MAAV,EAJA,CAKA,KAAKP,KAAL,iBAEJzE,+BACU,EAAmBA,SACrB,KAAKkE,IAAL,CAAU3D,GAAV,CAAc,OAAd,CADqBP,CAErB,KAAKkE,IAAL,CAAU3D,GAAV,CAAc,QAAd,CAFqBP,CAGrB,KAAKkE,IAAL,CAAU3D,GAAV,CAAc,OAAd,CAHqBP,EAKnB,EAAW,QAcjB,SAZiBkB,OAAOK,QAAQ,YAC5B,MAAe,EAAShB,GAAT,CAAa,EAAM0E,QAAnB,KAAf,CACA,EAAOzD,IAAP,CAAY,EAAML,OAAlB,EACA,EAASV,GAAT,CAAa,EAAMwE,QAAnB,GAHJ,GAKA,EAAS1D,OAAT,CAAiB,cACbZ,UACI,EAAKuD,IADTvD,CAEI,EAAIuE,KAAJ,CAAU,UAAV,EAAsBnC,MAAtB,CAA6B,kBAAW,MAAxC,CAAA,EAA4CoC,KAA5C,CAAkD,CAAlD,CAFJxE,GADJ,CAAA,EAOO,EAAiBO,oBAE5BwB,kBACI,MAAe,KAAK2B,MAApB,CACA,8BAAehH,SAAU+H,KAAMlG,cApFfzC,MAAMmG,WAEnByC,wBAAAA,CAAe,CAAEhJ,SAAF"}