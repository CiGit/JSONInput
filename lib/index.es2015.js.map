{"version":3,"file":"index.es2015.js","sources":["../src/Store/index.tsx","../src/Comps/defaultWidgets.tsx","../src/Comps/Fields/Widget.tsx","../src/Utils/customValidator.ts","../src/Store/actions.ts","../src/Comps/Decorators/validator.tsx","../src/Comps/Fields/Object.tsx","../src/Comps/Fields/String.tsx","../src/Comps/Fields/Number.tsx","../src/Comps/Fields/Boolean.tsx","../src/Comps/Fields/Array.tsx","../src/Comps/Fields/index.tsx","../src/Comps/Decorators/visible.tsx","../src/Comps/Fields/Undefined.tsx","../src/Utils/infer.ts","../src/Comps/Decorators/inference.tsx","../src/Comps/Decorators/fromDefaultValue.tsx","../src/Comps/SchemaType.tsx","../src/Comps/Container.tsx"],"sourcesContent":["import * as React from 'react';\nimport immer from 'immer';\n\ninterface StoreProps {\n  value?: {};\n  schema: {};\n  onValueChange: (value: {}) => void;\n  children: (\n    props: {\n      dispatch: (\n        action: (state: any, ...extraArgs: any[]) => void,\n        ...args: any[]\n      ) => void;\n      schema: {};\n      value: {};\n      status: {};\n    },\n  ) => JSX.Element;\n}\nconst FormContext = React.createContext<{\n  value?: {};\n  schema: {};\n  status: {};\n}>({\n  value: undefined,\n  schema: {},\n  status: {},\n});\nexport const FormConsumer = FormContext.Consumer;\nexport class Store extends React.Component<StoreProps> {\n  state = {\n    schema: {},\n    value: {},\n    status: {},\n    oldProps: {},\n  };\n  static getDerivedStateFromProps(\n    nextProps: StoreProps,\n    state: {\n      schema: {};\n      value: {};\n      status: {};\n      oldProps: StoreProps;\n    },\n  ) {\n    if (state.oldProps !== nextProps) {\n      let ret: Partial<typeof Store.prototype.state> = {\n        value: nextProps.value,\n        schema: nextProps.schema,\n        oldProps: nextProps,\n      };\n      if (nextProps.value !== state.value) {\n        ret.status = {};\n      }\n      return ret;\n    }\n    return null;\n  }\n  dispatch = (\n    action: (state: any, ...extraArgs: any[]) => void,\n    ...args: any[]\n  ) => {\n    this.setState(prevState => {\n      return (immer(action) as (state: any, ...extraArgs: any[]) => any)(\n        prevState,\n        ...args,\n      );\n    });\n  };\n  shouldComponentUpdate(nextProps: any, nextState: any) {\n    return this.state !== nextState;\n  }\n  componentDidUpdate(prevProps: StoreProps, prevState: { value: {} }) {\n    if (\n      this.state.value !== prevState.value &&\n      // This is not an update due to a props change.\n      this.props.value === prevProps.value\n    ) {\n      this.props.onValueChange(this.state.value);\n    }\n  }\n  render() {\n    const { schema, value, status } = this.state;\n    return (\n      <FormContext.Provider value={this.state}>\n        {this.props.children({\n          schema,\n          value,\n          status,\n          dispatch: this.dispatch,\n        })}\n      </FormContext.Provider>\n    );\n  }\n}\n","import * as React from 'react';\nimport { WidgetProps } from '../../typings/types';\n\nexport type WidgetMap = {\n  [key: string]: React.ComponentClass<WidgetProps> | React.SFC<WidgetProps>;\n};\n\nfunction undefinedWidgetFactory(type: string) {\n  return function UndefinedWidget() {\n    return <span>{`Widget for '${type}' was not defined`}</span>;\n  };\n}\nlet DefaultWidget: WidgetMap = {};\n\nfunction defaultWidget(type: string) {\n  return DefaultWidget[type] || undefinedWidgetFactory(type);\n}\n\nfunction setDefaultWidgets(obj: WidgetMap) {\n  DefaultWidget = Object.assign({}, DefaultWidget, obj);\n}\n\nexport { defaultWidget, setDefaultWidgets };\n","import * as React from 'react';\nimport { defaultWidget } from '../defaultWidgets';\n\nimport { WidgetProps, TYPESTRING, Schema } from '../../../typings/types';\n\ntype Props = {\n  value?: {};\n  schema: Schema & { type: TYPESTRING };\n  editKey: string;\n  onChange: (value: any) => void;\n  errorMessage?: string[];\n  path: string[];\n  children?: (React.ComponentClass<WidgetProps> | React.SFC<WidgetProps>)[];\n  addKey?: (key: string, value: {}) => void;\n  removeKey?: (key: string) => void;\n  alterKey?: (key: string, newKey: string) => void;\n  onChildAdd?: () => void;\n  onChildRemove?: (index: number) => void;\n};\n\nconst EMPTYOBJECT = {};\nfunction Widget<P extends Props>(props: P) {\n  const {\n    value,\n    schema,\n    schema: { view },\n    children,\n    editKey,\n    path,\n    onChange,\n    onChildAdd,\n    onChildRemove,\n    addKey,\n    removeKey,\n    alterKey,\n    errorMessage,\n  } = props;\n  const forwardProps = {\n    value,\n    schema,\n    children,\n    editKey,\n    path,\n    onChange,\n    onChildAdd,\n    onChildRemove,\n    addKey,\n    removeKey,\n    alterKey,\n    errorMessage,\n  };\n  if (view) {\n    const { type } = view;\n    if (typeof type === 'string') {\n      const Wdgt = defaultWidget(type);\n      return <Wdgt {...forwardProps} view={view} />;\n    }\n    if (typeof type === 'function') {\n      const Type = type;\n      return <Type {...forwardProps} view={view} />;\n    }\n  }\n  let renderType = Array.isArray(schema.type)\n    ? (schema.type as TYPESTRING[]).find(t => t !== 'null')\n    : schema.type;\n  let Wdgt;\n  if (renderType === undefined) {\n    Wdgt = defaultWidget('undefinedType');\n  } else {\n    Wdgt = defaultWidget(renderType);\n  }\n  return <Wdgt {...forwardProps} view={view || EMPTYOBJECT} />;\n}\n\nexport default Widget;\n","import * as jsonschema from 'jsonschema';\nimport { ValidatorResult } from 'jsonschema/lib';\nimport { Schema, ErrorFn } from '../../typings/types';\n\nconst customValidator = new jsonschema.Validator();\ncustomValidator.attributes.errored = function validateErrored(\n  instance: {},\n  schema: { errored?: ErrorFn },\n  options: { formValue: {} },\n) {\n  if (typeof schema.errored !== 'function') {\n    throw new jsonschema.SchemaError('\"errored\" expects a function');\n  }\n  const msg = schema.errored(instance, options.formValue);\n  if (msg) {\n    return msg;\n  }\n  return undefined;\n};\nfunction validate(\n  value: {} | undefined,\n  schema: Schema,\n  formValue?: {},\n): ValidatorResult {\n  return customValidator.validate(value, schema, {\n    formValue: formValue || {},\n  });\n}\n\nexport default validate;\n","import { ValidationError } from 'jsonschema/lib';\nimport { set, get, unset } from 'lodash-es';\n\nconst VALUE = 'value';\nconst STATUS = 'status';\nconst STATE = '$$$state';\nconst ERRORS = '$$$errors';\nconst NO_ERRORS: string[] = [];\n\nfunction setErrors(state: any, path: string[] = [], errors: string[]) {\n  const errorPath = [STATUS].concat(path).concat([ERRORS]);\n  set(state, errorPath, errors);\n}\nexport function setValidationErrors(\n  state: any,\n  path: string[] = [],\n  errors: ValidationError[],\n) {\n  const errorMap = new Map<string, string[]>();\n  // Collect each error associated with a given path\n  errors.forEach(error => {\n    const errors = errorMap.get(error.property) || [];\n    errors.push(error.message); // Add new error\n    errorMap.set(error.property, errors);\n  });\n  setErrors(state, path, NO_ERRORS);\n  errorMap.forEach((value, key) => {\n    setErrors(\n      state,\n      path.concat(\n        key\n          .split(/\\.|\\[|\\]/)\n          .filter(x => x !== '')\n          .slice(1),\n      ),\n      value,\n    );\n  });\n}\n\n/**\n * Update a value in the tree\n *\n * @param state the tree\n * @param path path's value to update\n * @param value value to set\n * @param errors errors relative to the value\n */\nexport function update(\n  state: any,\n  path: string[] = [],\n  value: {},\n  errors: ValidationError[],\n) {\n  const statusPath = [STATUS].concat(path);\n  set(state, [VALUE].concat(path), value);\n  set(state, statusPath.concat([STATE]), 'dirty');\n  setValidationErrors(state, path, errors);\n}\n\nexport function setDefaultValue(state: any, path: string[] = [], value: {}) {\n  update(state, path, value, []);\n  set(state, [STATUS].concat(path).concat([STATE]), 'pristine');\n}\n\n/**\n * Unset given path\n * @param state the tree\n * @param path path to value\n */\nexport function destroy(state: any, path: string[] = []) {\n  try {\n    unset(state, [STATUS].concat(path));\n  } catch (e) {\n    // Maybe already destroyed\n  }\n}\n\n// GETTERS, DO NOT USE with a dispatcher\n\nexport function getErrors(state: any, path: string[] = []) {\n  return get(state, [STATUS].concat(path).concat([ERRORS])) || NO_ERRORS;\n}\n","import * as React from 'react';\nimport validate from './../../Utils/customValidator';\nimport { getErrors } from '../../Store/actions';\n\nimport { Schema, Action } from '../../../typings/types';\nimport { ValidationError } from 'jsonschema/lib';\nimport { FormConsumer } from '../../Store';\n\ntype Props = {\n  schema: Schema;\n  value?: any;\n  dispatch: (action: Action, ...args: {}[]) => any;\n  path: string[];\n  onChange: (value: any, errors?: ValidationError[]) => void;\n};\n\nfunction validated<P extends Props>(\n  Comp: React.ComponentType<P & { errorMessage?: string[] }>,\n) {\n  class Validator extends React.Component<P & { __tree: any }> {\n    onChange = (val?: {}) => {\n      const validation = validate(\n        val,\n        this.props.schema,\n        this.props.__tree.value,\n      );\n      this.props.onChange(val, validation.errors);\n    };\n    shouldComponentUpdate(nextProps: P & { __tree: any }) {\n      return (\n        this.props.value !== nextProps.value ||\n        this.props.schema !== nextProps.schema ||\n        getErrors(this.props.__tree, this.props.path) !==\n          getErrors(nextProps.__tree, nextProps.path)\n      );\n    }\n    render() {\n      const { path } = this.props;\n      return (\n        <Comp\n          {...this.props}\n          errorMessage={getErrors(this.props.__tree, path)}\n          onChange={this.onChange}\n        />\n      );\n    }\n  }\n  return (p: P) => {\n    return (\n      <FormConsumer>{tree => <Validator {...p} __tree={tree} />}</FormConsumer>\n    );\n  };\n}\n\nexport default validated;\n","import * as React from 'react';\nimport SchemaType from '../SchemaType';\nimport Widget from './Widget';\nimport validator from '../Decorators/validator';\n\nimport { Schema, Action } from '../../../typings/types';\n\ntype Props = {\n  schema: Schema.Object;\n  status: { [key: string]: {} };\n  dispatch: (action: Action, ...args: {}[]) => any;\n  editKey: string;\n  value: {\n    [key: string]: {};\n  };\n  path: string[];\n  onChange: (value: {}) => void;\n};\n/**\n * Get schema from properties field\n * @param schema Object's schema\n * @param prop prop to get schema for\n */\nfunction schemaFromProperties(schema: Schema.Object, prop: string) {\n  const { properties = {} } = schema;\n  if (prop in properties) {\n    return properties[prop];\n  }\n}\n/**\n * Retrieve **first** matching schema from patternProperties\n * @param schema Object's schema\n * @param prop prop to get schema for\n */\nfunction schemaFromPattern(schema: Schema.Object, prop: string) {\n  const patternProperties = schema.patternProperties || {};\n  const patterns = Object.keys(patternProperties);\n  const p = patterns.find(p => new RegExp(p).test(prop));\n  if (p) {\n    return patternProperties[p];\n  }\n}\n/**\n * Get schema for a given property\n * @param schema Object's schema\n * @param prop prop to get schema for\n */\nfunction schemaForProp(schema: Schema.Object, prop: string) {\n  return (\n    schemaFromProperties(schema, prop) ||\n    schemaFromPattern(schema, prop) ||\n    schema.additionalProperties\n  );\n}\nconst EMPTY_OBJECT = {};\n\nfunction renderChildren(props: Props): JSX.Element[] {\n  const children = [];\n  const properties = props.schema.properties || {};\n  const value: { [key: string]: {} } = props.value || {};\n  // Holds schema properties and value properties missing from schema.\n  const mergedProperties: Array<string> = Object.keys(properties);\n\n  Object.keys(value).forEach(v => {\n    if (v in properties) {\n      return;\n    }\n    mergedProperties.push(v);\n  });\n  function indexFor(property: string): number {\n    if (properties[property]) {\n      const index = properties[property].index;\n      if (typeof index === 'number') {\n        return index;\n      }\n    }\n    return 0;\n  }\n  // Index based sorting\n  function sortProperties(a: string, b: string): number {\n    return indexFor(a) - indexFor(b);\n  }\n\n  mergedProperties.sort(sortProperties);\n  for (let i: number = 0; i < mergedProperties.length; i += 1) {\n    const prop: string = mergedProperties[i];\n    const propSchema = schemaForProp(props.schema, prop);\n    children.push(\n      <SchemaType\n        {...props}\n        status={props.status[prop] || EMPTY_OBJECT}\n        schema={propSchema}\n        value={value[prop]}\n        editKey={prop}\n        key={i}\n      />,\n    );\n  }\n  return children;\n}\n\nfunction ObjectField(props: Props) {\n  function addKey(key: string, value: {}): void {\n    if (typeof props.value === 'object' && key in props.value) {\n      throw new Error(`Property \"${key}\" already exists`);\n    }\n    props.onChange(\n      Object.assign({}, props.value, {\n        [key]: value,\n      }),\n    );\n  }\n\n  function removeKey(key: string): void {\n    const value: { [key: string]: {} } = Object.assign({}, props.value);\n    delete value[key];\n    props.onChange(value);\n  }\n\n  function alterKey(key: string, newKey: string): void {\n    if (key === newKey) {\n      return;\n    }\n    if (newKey in props.value) {\n      throw new Error(`Property \"${newKey}\" already exists`);\n    }\n    const value: { [key: string]: {} } = {};\n    Object.keys(props.value).forEach(p => {\n      if (p !== key) {\n        value[p] = props.value[p];\n      } else {\n        value[newKey] = props.value[p];\n      }\n    });\n    props.onChange(value);\n  }\n  return (\n    <Widget\n      {...props as any}\n      addKey={addKey}\n      removeKey={removeKey}\n      alterKey={alterKey}\n    >\n      {renderChildren(props)}\n    </Widget>\n  );\n}\n\nexport default validator(ObjectField);\n","import * as React from 'react';\nimport Widget from './Widget';\nimport validator from '../Decorators/validator';\n\nimport { Schema, Action } from '../../../typings/types';\n\ntype Props = {\n  schema: Schema & { type: 'number' | 'string' };\n  value?: number | string;\n  editKey: string;\n  path: string[];\n  onChange: (value: string | number) => void;\n  dispatch: (action: Action, ...args: {}[]) => any;\n};\n\nfunction StringField(props: Props) {\n  return <Widget {...props} />;\n}\n\nexport { StringField as SimpleStringField };\nexport default validator<Props>(StringField);\n","import * as React from 'react';\nimport validator from '../Decorators/validator';\nimport { SimpleStringField } from './String';\nimport { Schema, Action } from '../../../typings/types';\n\ninterface Props {\n  schema: Schema & { type: 'number' | 'string' };\n  value?: number;\n  editKey: string;\n  path: string[];\n  dispatch: (action: Action, ...args: {}[]) => any;\n  onChange: (value: string | void | number) => void;\n}\n/**\n * Transform to numeric value or undefined. Used to compare exp,\n * binary, hexa, ... strings\n * @param value value to convert\n */\nfunction toNumber(value?: string | number) {\n  switch (typeof value) {\n    case 'number':\n      return value;\n    case 'string':\n      return value === '' ? undefined : Number(value);\n    default:\n      return undefined;\n  }\n}\nclass NumberField extends React.Component<Props, { value?: string | number }> {\n  static getDerivedStateFromProps = (\n    props: Props,\n    state: { value?: string | number },\n  ) => {\n    if (toNumber(state.value) !== toNumber(props.value)) {\n      return {\n        value: props.value,\n      };\n    }\n    return null;\n  };\n  state = { value: this.props.value };\n  onChange = (val?: string | number) => {\n    const value: string | number | undefined = val === '' ? undefined : val;\n    const numVal = Number(value);\n    this.setState(\n      {\n        value,\n      },\n      () => this.props.onChange(isNaN(numVal) ? value : numVal),\n    );\n  };\n  render() {\n    return (\n      <SimpleStringField\n        {...this.props}\n        value={this.state.value}\n        onChange={this.onChange}\n      />\n    );\n  }\n}\nexport default validator<Props>(NumberField);\n","import * as React from 'react';\nimport Widget from './Widget';\nimport validator from './../Decorators/validator';\n\nimport { Schema, Action } from '../../../typings/types';\ninterface Props {\n  schema: Schema & { type: 'boolean' };\n  editKey: string;\n  path: string[];\n  value: boolean;\n  onChange: (value?: boolean) => void;\n  dispatch: (action: Action, ...args: {}[]) => any;\n}\nfunction BooleanField(props: Props) {\n  return <Widget {...props} />;\n}\n\nexport default validator(BooleanField);\n","import * as React from 'react';\nimport SchemaType from '../SchemaType';\nimport Widget from './Widget';\nimport validator from '../Decorators/validator';\n\nimport { Schema, Action } from '../../../typings/types';\n\ntype Props = {\n  onChange: (val: {}[]) => void;\n  schema: Schema & {\n    type: 'array';\n    items?: Schema[] | Schema;\n    value?: {}[];\n  };\n  dispatch: (action: Action, ...args: ({} | undefined)[]) => any;\n  value?: {}[];\n  editKey: string;\n  status: { [key: string]: {} };\n  path: string[];\n  [key: string]: any;\n};\nconst EMPTY_OBJECT = {};\n\nfunction onChildRemove(props: Props) {\n  return function onRemove(index: number) {\n    const oldValue = props.value || [];\n    props.onChange(oldValue.filter((e, i) => Number(i) !== Number(index)));\n  };\n}\n\nfunction onChildAdd(props: Props) {\n  return function onAdd(value?: {}) {\n    const oldValue = props.value || [];\n    props.onChange(oldValue.concat([value]));\n  };\n}\n\nfunction renderChildren(props: Props) {\n  const {\n    value,\n    schema: { items },\n  } = props;\n  let valueItems: {}[];\n  if (value) {\n    valueItems = value;\n  } else {\n    valueItems = [];\n  }\n  const children: JSX.Element[] = [];\n  valueItems.forEach((val, i) =>\n    children.push(\n      <SchemaType\n        {...props}\n        schema={Array.isArray(items) ? items[i] || {} : items}\n        value={val}\n        editKey={String(i)}\n        status={props.status[String(i)] || EMPTY_OBJECT}\n        key={i}\n      />,\n    ),\n  );\n  return children;\n}\n\nfunction ArrayField(props: Props) {\n  return (\n    <Widget\n      {...props as any}\n      onChildAdd={onChildAdd(props)}\n      onChildRemove={onChildRemove(props)}\n    >\n      {renderChildren(props)}\n    </Widget>\n  );\n}\n\nexport default validator<Props>(ArrayField);\n","import ObjectField from './Object';\nimport StringField from './String';\nimport NumberField from './Number';\nimport BooleanField from './Boolean';\nimport ArrayField from './Array';\n\nexport default {\n  object: ObjectField,\n  string: StringField,\n  number: NumberField,\n  boolean: BooleanField,\n  array: ArrayField,\n};\n","import * as React from 'react';\nimport { Action, Schema } from '../../../typings/types';\nimport { FormConsumer } from '../../Store';\n\ntype Props = {\n  schema: Schema;\n  path: string[];\n  value?: {};\n  dispatch: (action: Action, ...args: {}[]) => any;\n};\nfunction visibility<P extends Props>(\n  Comp: React.ComponentClass<P> | React.SFC<P>,\n): React.SFC<P> {\n  return function Visible(props: P) {\n    const {\n      schema: { visible },\n      value,\n    } = props;\n\n    return (\n      <FormConsumer>\n        {({ value: formValue }) => {\n          try {\n            if (\n              visible &&\n              !visible(\n                value,\n                formValue,\n                props.path.concat(), // Copy\n              )\n            ) {\n              return null!;\n            }\n          } catch (e) {\n            return null!;\n          }\n          return <Comp {...props} />;\n        }}\n      </FormConsumer>\n    );\n  };\n}\n\nexport default visibility;\n","import * as React from 'react';\n\nimport { WidgetProps } from '../../../typings/types';\n\nfunction Undefined(props: WidgetProps) {\n  return (\n    <div\n    >{`Undefined field type \"${props.schema.type!.toString()}\", [${props.path.toString()}]`}</div>\n  );\n}\n\nexport default Undefined;\n","export default function infer(value?: {}) {\n  switch (typeof value) {\n    case 'number':\n      return 'number';\n    case 'string':\n      return 'string';\n    case 'boolean':\n      return 'boolean';\n    case 'object':\n      return Array.isArray(value) ? 'array' : 'object';\n    default:\n      return 'string';\n  }\n}\n","import * as React from 'react';\nimport infer from './../../Utils/infer';\nimport { Schema } from '../../../typings/types';\n/**\n * Update store's value path.\n * @param {Array<string>} currentValuePath the valuePath the parent\n * @param {string} editKey the key currently edited\n * @returns {Array<string>}the updated valuePath\n */\nfunction updatePath(currentPath: string[], editKey?: string): string[] {\n  if (editKey !== undefined) {\n    return currentPath.concat([editKey]);\n  }\n  return currentPath;\n}\ninterface InferProps {\n  path: string[];\n  editKey?: string;\n  value?: {};\n  schema?: Schema;\n  [p: string]: any;\n}\ninterface InferState {\n  schema: Schema;\n  path: string[];\n  oldPath: string[] | null;\n  oldEditKey: string | null;\n  oldValue?: {};\n}\n/**\n * HOC, compute schema value from inferred type if schema is missing\n * @param Comp component to decorate.\n * @return the decorated component.\n */\nfunction inference<P extends InferProps>(Comp: React.ComponentType<P>) {\n  class Infer extends React.Component<InferProps, InferState> {\n    state: InferState = {\n      path: [],\n      schema: {},\n      oldPath: null,\n      oldEditKey: null,\n    };\n    static getDerivedStateFromProps(\n      nextProps: P,\n      curState: InferState,\n    ): Partial<InferState> {\n      let nextState: Partial<InferState> = {};\n      if (\n        curState.oldEditKey !== nextProps.editKey ||\n        curState.oldPath !== nextProps.path\n      ) {\n        nextState.path = updatePath(nextProps.path, nextProps.editKey);\n        nextState.oldPath = nextProps.path;\n        nextState.oldEditKey = nextProps.editKey;\n      }\n      if (\n        curState.schema !== nextProps.schema ||\n        infer(nextProps.value) !== infer(curState.oldValue)\n      ) {\n        let inferredSchema = nextProps.schema || {};\n        if (!('type' in inferredSchema)) {\n          inferredSchema = {\n            type: infer(nextProps.value),\n            ...inferredSchema,\n          };\n        }\n        nextState.schema = inferredSchema;\n        // nextState.oldSchema = nextProps.schema;\n      }\n      return nextState;\n    }\n\n    render() {\n      const { type } = this.state.schema;\n      return (\n        <Comp\n          // Recreate component on type change\n          key={Array.isArray(type) ? undefined : type}\n          {...this.props}\n          path={this.state.path}\n          schema={this.state.schema}\n        />\n      );\n    }\n  }\n  return Infer;\n}\n\nexport default inference;\n","import * as React from 'react';\nimport { cloneDeep } from 'lodash-es';\nimport { setDefaultValue } from '../../Store/actions';\nimport { Action, Schema } from '../../../typings/types';\n\nexport type Props = {\n  editKey?: string;\n  path: string[];\n  status: {\n    $$$state?: string;\n  };\n  value?: {};\n  schema: Schema;\n  dispatch: (action: Action, ...args: ({} | undefined)[]) => any;\n};\nfunction updateDefault({\n  value,\n  schema: { value: defaultValue },\n  dispatch,\n  path,\n}: Props) {\n  const val = value !== undefined ? value : cloneDeep(defaultValue);\n  if (val !== value) {\n    dispatch(setDefaultValue, path, val);\n  }\n  return val;\n}\n\nfunction fromDefaultValue<P extends Props>(\n  Comp: React.ComponentClass<P> | React.SFC<P>,\n) {\n  class DefaultValue extends React.Component<P, { val?: {}; init: boolean }> {\n    static getDerivedStateFromProps(nextProps: P, state: { init: boolean }) {\n      if (state.init) {\n        return { init: false };\n      }\n      return {\n        val: nextProps.value,\n      };\n    }\n    state = { val: updateDefault(this.props), init: true };\n    render() {\n      return <Comp {...this.props} value={this.state.val} />;\n    }\n  }\n\n  return DefaultValue;\n}\n\nexport default fromDefaultValue;\n","import * as React from 'react';\nimport Fields from './Fields/index';\nimport visible from './Decorators/visible';\nimport UndefinedField from './Fields/Undefined';\nimport inference from './Decorators/inference';\nimport fromDefaultValue from './Decorators/fromDefaultValue';\nimport { update, destroy } from '../Store/actions';\n\nimport { Schema, Action, TYPESTRING } from '../../typings/types';\n\ntype SchemaProps = {\n  schema: Schema;\n  status: { [key: string]: {} };\n  path: string[];\n  dispatch: (action: Action, ...args: ({} | undefined)[]) => any;\n  editKey?: string;\n  value?: {};\n};\n\n/**\n * Component generating the correct field based on schema.type\n * @constructor\n * @param {Object} props\n */\nclass SchemaType<P extends SchemaProps> extends React.Component<P> {\n  static defaultProps = {\n    path: [],\n  };\n  constructor(props: P) {\n    super(props);\n    this.onChange = this.onChange.bind(this);\n  }\n  onChange(...args: {}[]) {\n    this.props.dispatch(update, this.props.path, ...args);\n  }\n  componentWillUnmount() {\n    this.props.dispatch(destroy, this.props.path);\n  }\n  render() {\n    const {\n      schema: { type },\n    } = this.props;\n    const renderType = Array.isArray(type)\n      ? (type as TYPESTRING[]).find(t => t !== 'null')\n      : type;\n    let Type: React.ComponentClass<any> | React.SFC<any>;\n    if (renderType === undefined || renderType === 'null') {\n      Type = UndefinedField;\n    } else {\n      Type = Fields[renderType];\n    }\n    if (Type === undefined) {\n      Type = UndefinedField;\n    }\n    return <Type {...this.props} onChange={this.onChange} />;\n  }\n}\nexport default inference(fromDefaultValue(visible(SchemaType)));\n","import * as React from 'react';\nimport { Store } from '../Store/index';\nimport SchemaType from './SchemaType';\nimport validate from './../Utils/customValidator';\nimport { setValidationErrors } from '../Store/actions';\n\nimport { Schema } from '../../typings/types';\n\nconst EMPTY_ARRAY: any[] = [];\n\nexport type Props = {\n  onChange: (value: {}, errors: {}[]) => void;\n  schema: Schema;\n  value?: {};\n};\n/**\n * Top Component\n */\nclass Container extends React.Component<Props> {\n  store: Store | null = null;\n  static defaultProps = { schema: {} };\n  getValue() {\n    return this.store!.state.value;\n  }\n  update = (value: {}) => {\n    this.props.onChange(\n      value,\n      validate(value, this.props['schema'], value).errors,\n    );\n  };\n  validate() {\n    const validationResult = validate(\n      this.store!.state.value,\n      this.store!.state.schema,\n      this.store!.state.value,\n    );\n    this.store!.dispatch(setValidationErrors, [], validationResult.errors);\n    return validationResult.errors;\n  }\n  render() {\n    return (\n      <Store\n        ref={s => {\n          this.store = s;\n        }}\n        value={this.props.value}\n        schema={this.props.schema}\n        onValueChange={this.update}\n      >\n        {({ schema, value, status, dispatch }) => (\n          <SchemaType\n            schema={schema}\n            dispatch={dispatch}\n            value={value}\n            path={EMPTY_ARRAY}\n            status={status}\n          />\n        )}\n      </Store>\n    );\n  }\n}\n\nexport default Container;\n"],"names":["FormContext","React","undefined","FormConsumer","Consumer","Store","action","args","setState","immer","prevState","getDerivedStateFromProps","nextProps","state","oldProps","ret","value","schema","status","shouldComponentUpdate","nextState","this","componentDidUpdate","prevProps","props","onValueChange","render","React.createElement","Provider","children","dispatch","undefinedWidgetFactory","type","DefaultWidget","defaultWidget","setDefaultWidgets","obj","Object","assign","EMPTYOBJECT","Widget","view","forwardProps","editKey","path","onChange","onChildAdd","onChildRemove","addKey","removeKey","alterKey","errorMessage","Wdgt","_Wdgt","renderType","Array","isArray","find","t","customValidator","jsonschema","validate","formValue","attributes","errored","instance","options","msg","VALUE","STATUS","STATE","ERRORS","NO_ERRORS","setErrors","errors","errorPath","concat","setValidationErrors","errorMap","Map","forEach","get","error","property","push","message","set","key","split","filter","x","slice","update","statusPath","setDefaultValue","destroy","e","getErrors","validated","Comp","Validator","val","validation","_this","__tree","p","tree","schemaFromProperties","prop","properties","schemaFromPattern","patternProperties","keys","RegExp","test","schemaForProp","additionalProperties","EMPTY_OBJECT","renderChildren","mergedProperties","indexFor","index","v","sort","a","b","i","length","propSchema","SchemaType","ObjectField","babelHelpers.typeof","Error","newKey","validator","StringField","toNumber","Number","NumberField","numVal","isNaN","SimpleStringField","BooleanField","oldValue","items","String","ArrayField","visibility","visible","Undefined","toString","infer","updatePath","currentPath","inference","curState","oldEditKey","oldPath","inferredSchema","updateDefault","defaultValue","cloneDeep","fromDefaultValue","init","_React$Component","bind","componentWillUnmount","Type","UndefinedField","Fields","EMPTY_ARRAY","Container","getValue","store","validationResult","ref","s"],"mappings":"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"}