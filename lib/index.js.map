{"version":3,"file":"index.js","sources":["../src/Comps/Decorators/fromDefaultValue.js","../src/Comps/Views/undefinedWidgetFactory.js","../src/Comps/Decorators/labeled.js","../src/Comps/Views/Input.js","../src/Comps/Views/TextWidget.js","../src/Comps/Views/ArrowNumberWidget.js","../src/Comps/Views/CheckboxWidget.js","../src/Comps/Views/ArrayWidget.js","../src/Comps/Views/ObjectWidget.js","../src/Comps/Views/SelectWidget.js","../src/Comps/Views/index.js","../src/Comps/Views/Widget.js","../src/Utils/customValidator.js","../src/Comps/Decorators/validator.js","../src/Comps/Fields/Object.js","../src/Comps/Fields/String.js","../src/Comps/Fields/Boolean.js","../src/Comps/Fields/Array.js","../src/Comps/Decorators/visible.js","../src/Comps/Fields/Undefined.js","../src/Utils/infer.js","../src/Comps/Decorators/inference.js","../src/Comps/SchemaType.js","../src/Store/actions.js","../src/Store/index.js","../src/Comps/Fields/Number.js","../src/Comps/Fields/index.js","../src/Comps/Container.js","../src/index.js"],"sourcesContent":["import React, { PropTypes } from 'react';\n\nfunction updateDefault({ value, schema: { value: defaultValue } }) {\n    const val = value !== undefined ? value : defaultValue;\n    return val;\n}\n\nfunction fromDefaultValue(Comp) {\n    class DefaultValue extends React.Component {\n        constructor(props) {\n            super(props);\n            this.state = { val: updateDefault(props) };\n        }\n        componentDidMount() {\n            this.notifyDefaultChange();\n        }\n        componentWillReceiveProps(nextProps) {\n            this.setState({ val: updateDefault(nextProps) });\n        }\n        componentDidUpdate() {\n            this.notifyDefaultChange();\n        }\n        notifyDefaultChange() {\n            if (this.props.value !== this.state.val) {\n                this.props.actions.setDefaultValue(this.props.path, this.state.val);\n            }\n        }\n        render() {\n            return (<Comp {...this.props} value={this.state.val} />);\n        }\n    }\n\n    DefaultValue.propTypes = {\n        value: PropTypes.any, // eslint-disable-line\n        schema: PropTypes.shape({ // eslint-disable-line\n            value: PropTypes.any\n        }).isRequired,\n        path: PropTypes.arrayOf(PropTypes.string).isRequired,\n        actions: PropTypes.shape({\n            setDefaultValue: PropTypes.func.isRequired\n        }).isRequired\n    };\n    return DefaultValue;\n}\n\nexport default fromDefaultValue;\n","import React from 'react';\n\nfunction undefinedWidgetFactory(type) {\n    return function UndefinedWidget() {\n        return (\n            <span>\n                {`Widget for '${type}' was not defined`}\n            </span>\n        );\n    };\n}\n\nexport default undefinedWidgetFactory;\n","import React, { PropTypes } from 'react';\n\nfunction labeled(Comp) {\n    function Label(props) {\n        const required = props.schema.required;\n        const requiredClassName = required ? 'required' : '';\n        return (\n            <div>\n                <label //eslint-disable-line\n                    className={`${props.schema.type}Field ${requiredClassName}`}\n                >\n                    <span className=\"title\">{props.view.title || props.editKey}</span>\n                    <Comp {...props} />\n                    <span>{props.view.description}</span>\n                    <span>{props.errorMessage}</span>\n                </label>\n            </div>\n        );\n    }\n\n    Label.propTypes = {\n        schema: PropTypes.shape({\n            type: PropTypes.oneOfType([\n                PropTypes.oneOf(['object', 'string', 'number', 'array', 'boolean']),\n                PropTypes.arrayOf(\n                    PropTypes.oneOf(['object', 'string', 'number', 'array', 'boolean', 'null'])\n                )\n            ]).isRequired,\n            required: PropTypes.bool,\n            description: PropTypes.string\n        }).isRequired,\n        editKey: PropTypes.string,\n        view: PropTypes.shape({\n            title: PropTypes.string,\n            description: PropTypes.string\n        }).isRequired,\n        errorMessage: PropTypes.arrayOf(PropTypes.string)\n    };\n    Label.defaultProps = {\n        editKey: '',\n        errorMessage: []\n    };\n    return Label;\n}\n\nexport default labeled;\n","import React, { PropTypes } from 'react';\n\nfunction onInputChange(func) {\n    return function onChange(event) {\n        if (event.target.type === 'checkbox') {\n            func(event.target.checked);\n        } else {\n            func(event.target.value);\n        }\n    };\n}\n\nfunction Input(props) {\n    return (\n        <input\n            type={props.type}\n            placeholder={props.schema.placeholder}\n            value={props.value}\n            className={props.className}\n            onChange={onInputChange(props.onChange)}\n            checked={props.checked}\n        />\n    );\n}\n\nInput.propTypes = {\n    type: PropTypes.string.isRequired,\n    className: PropTypes.string,\n    onChange: PropTypes.func.isRequired,\n    checked: PropTypes.bool,\n    value: PropTypes.any, // eslint-disable-line\n    schema: PropTypes.shape({\n        placeholder: PropTypes.string\n    }).isRequired\n};\nInput.defaultProps = {\n    className: undefined,\n    checked: false\n};\nexport default Input;\n","import React from 'react';\nimport labeled from '../Decorators/labeled';\nimport Input from './Input';\n\nfunction TextWidget(props) {\n    return (\n        <Input\n            {...props}\n            type=\"string\"\n        />\n    );\n}\n\nexport default labeled(TextWidget);\n","import React from 'react';\nimport labeled from '../Decorators/labeled';\nimport Input from './Input';\n\nfunction ArrowNumberWidget(props) {\n    return (\n        <Input\n            {...props}\n            type=\"number\"\n        />\n    );\n}\n\nexport default labeled(ArrowNumberWidget);\n","import React, { PropTypes } from 'react';\nimport labeled from '../Decorators/labeled';\nimport Input from './Input';\n\nfunction CheckboxWidget(props) {\n    return (\n        <Input\n            {...props}\n            type=\"checkbox\"\n            checked={props.value}\n        />\n    );\n}\n\nCheckboxWidget.propTypes = {\n    value: PropTypes.bool\n};\nCheckboxWidget.defaultProps = { value: false };\n\nexport default labeled(CheckboxWidget);\n","import React, { PropTypes } from 'react';\nimport labeled from '../Decorators/labeled';\n\nfunction ArrayWidget(props) {\n    function renderChild(child, index) {\n        return (<div>\n            <button onClick={props.onChildRemove(index)}>-</button>\n            {child}\n        </div>);\n    }\n\n    const children = React.Children.map(props.children, renderChild);\n    return (\n        <div>\n            <div>\n                {children}\n            </div>\n            <button onClick={props.onChildAdd}>+</button>\n        </div>\n    );\n}\n\nArrayWidget.propTypes = {\n    children: PropTypes.arrayOf(PropTypes.element).isRequired,\n    onChildRemove: PropTypes.func.isRequired, // eslint-disable-line react/no-unused-prop-types\n    onChildAdd: PropTypes.func.isRequired\n};\nexport default labeled(ArrayWidget);\n","import React, { PropTypes } from 'react';\nimport labeled from '../Decorators/labeled';\n\nfunction ObjectWidget(props) {\n    return (\n        <div>\n            {props.children}\n        </div>\n    );\n}\n\nObjectWidget.propTypes = {\n    children: PropTypes.arrayOf(PropTypes.element).isRequired\n};\n\nexport default labeled(ObjectWidget);\n","import React, { PropTypes } from 'react';\n\nfunction SelectWidget({ view, value, onChange }) {\n    const choices = view.choices.map(c => (\n        <option\n            key={c.value}\n            value={c.value}\n        >\n            {c.label}\n        </option>\n    ));\n    return (\n        <select value={value} onChange={e => onChange(e.target.value)}>\n            {choices}\n        </select>\n    );\n}\nSelectWidget.propTypes = {\n    view: PropTypes.shape({\n        choices: PropTypes.arrayOf(PropTypes.shape({\n            value: PropTypes.any,\n            label: PropTypes.string.isRequired\n        })).isRequired\n    }).isRequired,\n    value: PropTypes.any, // eslint-disable-line\n    onChange: PropTypes.func.isRequired\n};\nexport default SelectWidget;\n","import undefinedWidgetFactory from './undefinedWidgetFactory';\nimport TextWidget from './TextWidget';\nimport ArrowNumberWidget from './ArrowNumberWidget';\nimport CheckboxWidget from './CheckboxWidget';\nimport ArrayWidget from './ArrayWidget';\nimport ObjectWidget from './ObjectWidget';\nimport SelectWidget from './SelectWidget';\n\nlet DefaultWidget = {\n    string: TextWidget,\n    number: TextWidget,\n    boolean: CheckboxWidget,\n    array: ArrayWidget,\n    object: ObjectWidget,\n    arrowNumber: ArrowNumberWidget,\n    select: SelectWidget\n};\n\nfunction defaultWidget(type) {\n    return DefaultWidget[type] || undefinedWidgetFactory(type);\n}\n\nfunction setDefaultWidgets(obj) {\n    DefaultWidget = Object.assign({}, DefaultWidget, obj);\n}\n\nexport { defaultWidget, setDefaultWidgets, undefinedWidgetFactory };\n","import React, { PropTypes } from 'react';\nimport { defaultWidget } from './index';\n\nconst EMPTYOBJECT = {};\nfunction Widget(props) {\n    const { schema } = props;\n    const { view, ...restSchema } = schema;\n    if (view) {\n        const { type } = view;\n        if (typeof type === 'string') {\n            const Wdgt = defaultWidget(type);\n            return (\n                <Wdgt\n                    {...props}\n                    schema={restSchema}\n                    view={view}\n                />\n            );\n        }\n        if (typeof type === 'function') {\n            const Type = type;\n            return (\n                <Type\n                    {...props}\n                    schema={restSchema}\n                    view={view}\n                />\n            );\n        }\n    }\n    const renderType = Array.isArray(schema.type) ?\n        schema.type.find(t => t !== 'null') :\n        schema.type;\n    const Wdgt = defaultWidget(renderType);\n    return (\n        <Wdgt\n            {...props}\n            schema={restSchema}\n            view={view || EMPTYOBJECT}\n        />\n    );\n}\n\nWidget.propTypes = {\n    schema: PropTypes.shape({\n        type: PropTypes.oneOfType([\n            PropTypes.string,\n            PropTypes.arrayOf(PropTypes.string)\n        ]).isRequired\n    }).isRequired\n};\nexport default Widget;\n","import jsonschema, { Validator } from 'jsonschema';\n\nconst customValidator = new Validator();\ncustomValidator.attributes.errored = function validateErrored(instance, schema, options) {\n    if (typeof schema.errored !== 'function') {\n        throw new jsonschema.SchemaError('\"errored\" expects a function');\n    }\n    const msg = schema.errored(instance, options.formValue);\n    if (msg) {\n        return msg;\n    }\n    return undefined;\n};\nfunction validate(value, schema, formValue) {\n    return customValidator.validate(value, schema, {\n        formValue\n    });\n}\n\nexport default validate ;\n","import React, { PropTypes } from 'react';\nimport validate from './../../Utils/customValidator';\n\nfunction validated(Comp) {\n    function Validator(props) {\n        function onChange(val) {\n            const validation = validate(val, props.schema, props.actions.getFormValue());\n            const err = validation.errors.map(error => error.message);\n            props.onChange(val, err);\n        }\n\n        return (\n            <Comp\n                {...props}\n                errorMessage={props.actions.getErrors(props.path)}\n                onChange={onChange}\n            />\n        );\n    }\n\n    Validator.propTypes = {\n        onChange: PropTypes.func.isRequired,\n        schema: PropTypes.shape({\n            errored: PropTypes.func\n        }).isRequired,\n        value: PropTypes.any, // eslint-disable-line\n        path: PropTypes.arrayOf(PropTypes.string).isRequired,\n        actions: PropTypes.objectOf(PropTypes.func).isRequired\n    };\n    return Validator;\n}\n\nexport default validated;\n","import React, { PropTypes } from 'react';\nimport SchemaType from '../SchemaType';\nimport fromDefaultValue from '../Decorators/fromDefaultValue';\nimport Widget from '../Views/Widget';\nimport validator from '../Decorators/validator';\n\n\nfunction renderChildren(props) {\n    const children = [];\n    const properties = props.schema.properties || {};\n    const value = props.value || {};\n    // Holds schema properties and value properties missing from schema.\n    const mergedProperties = Object.keys(properties);\n\n    Object.keys(value).forEach((v) => {\n        if (v in properties) {\n            return;\n        }\n        mergedProperties.push(v);\n    });\n\n    // Index based sorting\n    function sortProperties(a, b) {\n        const aIndex = properties[a] ? properties[a].index || 0 : 0;\n        const bIndex = properties[b] ? properties[b].index || 0 : 0;\n        return aIndex - bIndex;\n    }\n\n    mergedProperties.sort(sortProperties);\n    for (let i = 0; i < mergedProperties.length; i += 1) {\n        const prop = mergedProperties[i];\n        if (prop in properties) {\n            children.push(\n                <SchemaType\n                    {...props}\n                    schema={properties[prop]}\n                    value={value[prop]}\n                    editKey={prop}\n                    key={prop}\n                />\n            );\n        } else {\n            const schema = props.schema.defaultProperties;\n            if (schema) {\n                props.actions.updateSchema(props.path.concat([prop]), schema);\n            }\n            children.push(\n                <SchemaType\n                    {...props}\n                    schema={schema}\n                    value={value[prop]}\n                    editKey={prop}\n                    key={prop}\n                />\n            );\n        }\n    }\n    return children;\n}\n\nfunction ObjectField(props) {\n    function addKey(key, value) {\n        props.onChange(Object.assign({}, props.value, {\n            [key]: value\n        }));\n    }\n\n    function removeKey(key) {\n        const value = Object.assign({}, props.value);\n        delete value[key];\n        props.actions.deleteSchema(props.path.concat([key]), {});\n        props.onChange(value);\n    }\n\n    function alterKey(key, newKey) {\n        const value = {};\n        Object.keys(props.value).forEach((p) => {\n            if (p !== key) {\n                value[p] = props.value[p];\n            } else {\n                value[newKey] = props.value[p];\n            }\n        });\n        props.onChange(value);\n    }\n    return (\n        <Widget\n            {...props}\n            addKey={addKey}\n            removeKey={removeKey}\n            alterKey={alterKey}\n        >\n            {renderChildren(props)}\n        </Widget>\n    );\n}\n\nObjectField.propTypes = {\n    schema: PropTypes.shape({ // eslint-disable-line react/no-unused-prop-types\n        properties: PropTypes.object\n    }).isRequired,\n    value: PropTypes.any, // eslint-disable-line react/forbid-prop-types\n    path: PropTypes.arrayOf( // eslint-disable-line react/no-unused-prop-types\n        PropTypes.string\n    ).isRequired,\n    onChange: PropTypes.func.isRequired\n};\nObjectField.defaultProps = {\n    value: {}\n};\n\nexport default validator(fromDefaultValue(ObjectField));\n","import React, { PropTypes } from 'react';\nimport Widget from '../Views/Widget';\nimport fromDefaultValue from '../Decorators/fromDefaultValue';\nimport validator from '../Decorators/validator';\n\nfunction StringField(props) {\n    const val = props.value !== undefined && props.value !== null ?\n        String(props.value) :\n        props.value;\n    return (\n        <Widget\n            {...props}\n            value={val}\n        />\n    );\n}\n\nStringField.propTypes = {\n    value: PropTypes.oneOfType([ // eslint-disable-line react/require-default-props\n        PropTypes.number,\n        PropTypes.string\n    ])\n};\nexport { StringField as SimpleStringField };\nexport default validator(fromDefaultValue(StringField));\n","import React from 'react';\nimport Widget from '../Views/Widget';\nimport fromDefaultValue from '../Decorators/fromDefaultValue';\nimport validator from './../Decorators/validator';\n\nfunction BooleanField(props) {\n    return (<Widget {...props} />);\n}\n\nexport default validator(fromDefaultValue(BooleanField));\n","import React from 'react';\nimport SchemaType from '../SchemaType';\nimport Widget from '../Views/Widget';\nimport fromDefaultValue from '../Decorators/fromDefaultValue';\n\nfunction onChildChange(index, props) {\n    return function onChange(val) {\n        const { value } = props;\n        if (value) {\n            props.onChange(value.map((e, i) => {\n                if (+i !== +index) {\n                    return e;\n                }\n                return val;\n            }));\n        } else {\n            props.onChange([val]);\n        }\n    };\n}\n\nfunction onChildRemove(props) {\n    return function onRemove(index) {\n        return function doRemove() {\n            const oldValue = props.value || [];\n            props.onChange(oldValue.filter((e, i) => Number(i) !== Number(index)));\n        };\n    };\n}\n\nfunction onChildAdd(props) {\n    return function onAdd() {\n        const oldValue = props.value || [];\n        props.onChange(oldValue.concat([undefined]));\n    };\n}\n\nfunction renderChildren(props) {\n    const { value, schema: { defaultValue, items } } = props;\n    let valueItems;\n    if (value) {\n        valueItems = value;\n    } else if (defaultValue) {\n        valueItems = defaultValue;\n    } else {\n        valueItems = [];\n    }\n    const children = [];\n    valueItems.forEach((val, i) => children.push(\n        <SchemaType\n            {...props}\n            schema={Array.isArray(items) ? (items[i] || {}) : items}\n            value={val}\n            editKey={String(i)}\n            key={i} // eslint-disable-line react/no-array-index-key, should UID\n            onChange={onChildChange(i, props)}\n        />\n    ));\n    return children;\n}\n\nfunction ArrayField(props) {\n    return (\n        <Widget\n            {...props}\n            onChildAdd={onChildAdd(props)}\n            onChildRemove={onChildRemove(props)}\n        >\n            {renderChildren(props)}\n        </Widget>\n    );\n}\n\nexport default fromDefaultValue(ArrayField);\n","import React, { PropTypes } from 'react';\n\nfunction visibility(Comp) {\n    function Visible(props) {\n        const { schema: { visible }, value } = props;\n        if (visible && !visible(value, props.actions.getFormValue())) {\n            return null;\n        }\n        return (<Comp {...props} />);\n    }\n\n    Visible.propTypes = {\n        schema: PropTypes.shape({\n            visible: PropTypes.func\n        }).isRequired,\n        actions: PropTypes.objectOf(PropTypes.func).isRequired,\n        value: PropTypes.any // eslint-disable-line\n    };\n    return Visible;\n}\n\nexport default visibility;\n","import React, { PropTypes } from 'react';\n\nfunction Undefined(props) {\n    return (<span>{`Undefined field type \"${props.schema.type}\", [${props.path}]`}</span>);\n}\n\nUndefined.propTypes = {\n    schema: PropTypes.shape({\n        type: PropTypes.oneOfType([\n            PropTypes.oneOf(['object', 'string', 'number', 'array', 'boolean']),\n            PropTypes.arrayOf(\n                PropTypes.oneOf(['object', 'string', 'number', 'array', 'boolean', 'null'])\n            )\n        ]).isRequired\n    }).isRequired,\n    path: PropTypes.arrayOf(PropTypes.string).isRequired\n};\nexport default Undefined;\n","export default function infer(value) {\n    switch (typeof value) {\n    case 'number':\n        return 'number';\n    case 'string':\n        return 'string';\n    case 'boolean':\n        return 'boolean';\n    case 'object':\n        return Array.isArray(value) ? 'array' : 'object';\n    default:\n        return 'string';\n    }\n}\n","import React, { PropTypes } from 'react';\nimport infer from './../../Utils/infer';\n/**\n * Update store's value path.\n * @param {Array<string>} currentValuePath the valuePath the parent\n * @param {string} editKey the key currently edited\n * @returns {Array<string>}the updated valuePath\n */\nfunction updatePath(currentPath, editKey) {\n    if (editKey) {\n        return currentPath.concat([editKey]);\n    }\n    return currentPath;\n}\n\n/**\n * HOC, compute schema value from inferred type if schema is missing\n * @param {React.Component} Comp component to decorate.\n * @return {React.Component} the decorated component.\n */\nfunction inference(Comp) {\n    function Infer(props) {\n        const { schema } = props;\n        const path = updatePath(props.path, props.editKey);\n        let inferedSchema = schema;\n        if (!inferedSchema || !('type' in inferedSchema)) {\n            inferedSchema = { type: infer(props.value) };\n            // props.actions.updateSchema(path, schema);\n        }\n        return (\n            <Comp\n                {...props}\n                path={path}\n                schema={inferedSchema}\n            />\n        );\n    }\n\n    Infer.propTypes = {\n        schema: PropTypes.object, // eslint-disable-line\n        value: PropTypes.any, // eslint-disable-line\n        path: PropTypes.arrayOf(PropTypes.string).isRequired,\n        editKey: PropTypes.string // eslint-disable-line react/require-default-props\n    };\n    return Infer;\n}\n\nexport default inference;\n","import React, { PropTypes } from 'react';\nimport shouldPureComponentUpdate from 'react-pure-render/function';\nimport Fields from './Fields/index';\nimport visible from './Decorators/visible';\nimport UndefinedField from './Fields/Undefined';\nimport inference from './Decorators/inference';\n\n\n/**\n * bind function callback with its path\n * @param {function(Array<String>)} func callback function to bind\n * @param {Array<string>} path the value's path to act on\n */\nfunction doAction(func, path) {\n    return function action(...args) {\n        func(path, ...args);\n    };\n}\n\n/**\n * Component generating the correct field based on schema.type\n * @constructor\n * @param {Object} props\n */\nclass SchemaType extends React.Component {\n    constructor(props) {\n        super(props);\n        this.onChange = doAction(props.actions.update, props.path);\n    }\n    shouldComponentUpdate(...args) {\n        return shouldPureComponentUpdate.apply(this, args);\n    }\n    render() {\n        const { schema: { type } } = this.props;\n        const renderType = Array.isArray(type) ? type.find(t => t !== 'null') : type;\n        const Type = Fields[renderType] || UndefinedField;\n        return (\n            <Type\n                {...this.props}\n                onChange={this.onChange}\n            />\n        );\n    }\n}\n\nSchemaType.propTypes = {\n    schema: PropTypes.shape({\n        type: PropTypes.oneOfType([\n            PropTypes.oneOf(['object', 'string', 'number', 'array', 'boolean']),\n            PropTypes.arrayOf(\n                PropTypes.oneOf(['object', 'string', 'number', 'array', 'boolean', 'null'])\n            )\n        ]).isRequired\n    }).isRequired,\n    path: PropTypes.arrayOf(PropTypes.string).isRequired,\n    actions: PropTypes.objectOf(PropTypes.func).isRequired\n};\n\nexport default inference(visible(SchemaType));\n","const VALUE = 'value';\nconst STATUS = 'status';\nconst STATE = 'state';\nconst ERRORS = 'errors';\nconst NOERRORS = [];\n\nexport function setErrors(tree, path, errors) {\n    const errorPath = [STATUS].concat(path).concat([ERRORS]);\n    const errorsCursor = tree.select(errorPath);\n    if (errors && errors.length && Array.isArray(errorsCursor.get())) {\n        errorsCursor.splice([0, errorsCursor.get().length]);\n        errorsCursor.concat(errors || []);\n    } else {\n        errorsCursor.set(errors || NOERRORS);\n    }\n}\n\n/**\n * Update a value in the tree\n *\n * @param {Baobab} tree the tree\n * @param {Array<string>} path path's value to update\n * @param value value to set\n * @param {Array<string>} errors errors relative to the value\n */\nexport function update(tree, path, value, errors) {\n    const statusPath = [STATUS].concat(path);\n    tree.set([VALUE].concat(path), value);\n    tree.set(statusPath.concat([STATE]), 'dirty');\n    setErrors(tree, path, errors);\n}\n\nexport function setDefaultValue(tree, path, value) {\n    tree.set([VALUE].concat(path), value);\n    tree.set([STATUS].concat(path).concat([STATE]), 'pristine');\n}\n\nexport function getStatus(tree, path) {\n    return tree.get([STATUS].concat(path).concat([STATE]));\n}\n\nexport function getErrors(tree, path) {\n    return tree.get([STATUS].concat(path).concat([ERRORS])) || NOERRORS;\n}\n\nexport function getFormValue(tree) {\n    return tree.get(VALUE);\n}\n/**\n * handle object's \"properties\" path and array's \"item\" path\n */\nfunction schemaPath(tree, path) {\n    return path.reduce((prev, val) => {\n        if (tree.get(prev).type === 'object') {\n            return prev.concat(['properties', val]);\n        } else if (tree.get(prev).type === 'array') {\n            return prev.concat(['items']);\n        }\n        return prev.concat([val]);\n    }, ['schema']);\n}\nexport function updateSchema(tree, path, value) {\n    const updatedPath = schemaPath(tree, path);\n    tree.set(updatedPath, value);\n}\n\nexport function deleteSchema(tree, path) {\n    const updatedPath = schemaPath(tree, path);\n    tree.unset(updatedPath);\n}\n","import Baobab from 'baobab';\n\nconst createTree = () => new Baobab({\n    schema: {},\n    value: {},\n    status: {}\n});\n\nexport default createTree;\n","import React, { PropTypes } from 'react';\nimport validator from '../Decorators/validator';\nimport fromDefaultValue from '../Decorators/fromDefaultValue';\nimport { SimpleStringField } from './String';\n\nclass NumberField extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            value: props.value\n        };\n        this.boundChange = this.onChange.bind(this);\n    }\n    componentWillReceiveProps(nextProps) {\n        // if numerical values differ: update\n        if (Number(this.state.value) !== Number(nextProps.value)) {\n            this.setState({\n                value: nextProps.value\n            });\n        }\n    }\n    onChange(val) {\n        const value = val === '' ? undefined : val;\n        const numVal = Number(value);\n        this.setState({\n            value\n        }, () => this.props.onChange(isNaN(numVal) ? value : numVal));\n    }\n    render() {\n        return (\n            <SimpleStringField\n                {...this.props}\n                value={this.state.value}\n                onChange={this.boundChange}\n            />\n        );\n    }\n}\nNumberField.propTypes = {\n    value: PropTypes.number, // eslint-disable-line react/require-default-props\n    onChange: PropTypes.func.isRequired\n};\n\nexport default validator(fromDefaultValue(NumberField));\n","import ObjectField from './Object';\nimport StringField from './String';\nimport NumberField from './Number';\nimport BooleanField from './Boolean';\nimport ArrayField from './Array';\n\nexport default {\n    object: ObjectField,\n    string: StringField,\n    number: NumberField,\n    boolean: BooleanField,\n    array: ArrayField\n};\n","import React, { PropTypes } from 'react';\nimport { root, branch } from 'baobab-react/higher-order';\nimport createTree from '../Store/index';\nimport SchemaType from './SchemaType';\nimport * as actions from '../Store/actions';\nimport validate from './../Utils/customValidator';\n\nconst BranchedSchemaType = branch({\n    schema: 'schema',\n    status: 'status',\n    value: 'value'\n}, SchemaType);\nconst TYPES = ['string', 'number', 'boolean', 'object', 'array', 'null'];\n/**\n * Top Component\n */\nclass Container extends React.Component {\n    constructor(props) {\n        super(props);\n        this.tree = createTree();\n        this.updateTree(props.value, props.schema);\n        // should use dispatcher instead. from baobab-react v2\n        this.ACTIONS = {};\n        Object.keys(actions)\n            .forEach(action => (\n                this.ACTIONS[action] = actions[action].bind(this.tree, this.tree)\n            ));\n        this.rooted = root(this.tree, BranchedSchemaType);\n    }\n    componentWillReceiveProps(nextProps) {\n        this.updateTree(nextProps.value, nextProps.schema);\n    }\n    shouldComponentUpdate() {\n        return false;\n    }\n    componentWillUnmount() {\n        this.tree.release();\n    }\n    getValue() {\n        return this.tree.get('value');\n    }\n    updateTree(value, schema) {\n        this.tree.select('value').release();\n        this.tree.select('value').set(value);\n        this.tree.select('schema').set(schema);\n        this.tree.select('status').release();\n        this.tree.commit();\n        this.tree.select('value')\n            .on('update', event =>\n                this.props.onChange(\n                    event.data.currentData,\n                    validate(\n                        event.data.currentData,\n                        this.tree.get('schema'),\n                        event.data.currentData\n                    ).errors\n                )\n            );\n    }\n    validate() {\n        const validationResult = validate(this.tree.get('value'),\n            this.tree.get('schema'), this.tree.get('value'));\n        const { setErrors } = this.ACTIONS;\n        const errorMap = new Map();\n        // Collect each error associated with a given path\n        validationResult.errors.forEach((error) => {\n            const errors = errorMap.get(error.property) || [];\n            errors.push(error.message); // Add new error\n            errorMap.set(error.property, errors);\n        });\n        errorMap.forEach((value, key) => {\n            setErrors(key.split(/\\.|\\[|\\]/).filter(x => x !== '').slice(1), value);\n        });\n        return validationResult.errors;\n    }\n    render() {\n        const Rooted = this.rooted;\n        return (\n            <Rooted\n                onChange={this.props.onChange}\n                path={[]}\n                actions={this.ACTIONS}\n            />\n        );\n    }\n}\nContainer.propTypes = {\n    onChange: PropTypes.func.isRequired,\n    schema: PropTypes.shape({\n        type: PropTypes.oneOfType([PropTypes.oneOf(TYPES),\n            PropTypes.arrayOf(PropTypes.oneOf(TYPES))])\n    }),\n    value: PropTypes.any // eslint-disable-line\n};\nContainer.defaultProps = {\n    schema: {}\n};\n\nexport default Container;\n","import Container from './Comps/Container';\nimport { setDefaultWidgets } from './Comps/Views/index';\n\nContainer.setDefaultWidgets = setDefaultWidgets;\nexport default Container;\n"],"names":["updateDefault","value","defaultValue","schema","val","undefined","fromDefaultValue","Comp","DefaultValue","props","_React$Component","state","componentDidMount","notifyDefaultChange","componentWillReceiveProps","nextProps","setState","componentDidUpdate","this","actions","setDefaultValue","path","render","React","Component","undefinedWidgetFactory","type","labeled","Label","required","requiredClassName","className","view","title","editKey","description","errorMessage","defaultProps","onInputChange","func","event","target","checked","Input","placeholder","onChange","TextWidget","ArrowNumberWidget","CheckboxWidget","ArrayWidget","renderChild","child","index","onClick","onChildRemove","children","Children","map","onChildAdd","ObjectWidget","SelectWidget","choices","c","label","e","defaultWidget","DefaultWidget","setDefaultWidgets","obj","Object","assign","Widget","restSchema","Wdgt","_Wdgt","Type","renderType","Array","isArray","find","t","EMPTYOBJECT","validate","formValue","customValidator","validated","Validator","validation","getFormValue","err","errors","error","message","getErrors","renderChildren","sortProperties","a","b","aIndex","properties","bIndex","mergedProperties","keys","forEach","v","push","sort","i","length","prop","SchemaType","defaultProperties","updateSchema","concat","ObjectField","addKey","key","removeKey","deleteSchema","alterKey","newKey","p","StringField","String","BooleanField","onChildChange","oldValue","filter","Number","items","valueItems","ArrayField","visibility","Visible","visible","Undefined","infer","updatePath","currentPath","inference","Infer","inferedSchema","doAction","args","setErrors","tree","errorPath","STATUS","ERRORS","errorsCursor","select","get","splice","set","NOERRORS","update","statusPath","VALUE","STATE","getStatus","schemaPath","reduce","prev","updatedPath","unset","createTree","Baobab","attributes","errored","instance","options","jsonschema","SchemaError","msg","validator","NumberField","boundChange","_this","bind","numVal","_this2","isNaN","SimpleStringField","shouldComponentUpdate","shouldPureComponentUpdate","apply","Fields","UndefinedField","BranchedSchemaType","branch","Container","updateTree","ACTIONS","action","rooted","root","componentWillUnmount","release","getValue","commit","on","data","currentData","validationResult","errorMap","Map","property","split","x","slice","Rooted"],"mappings":"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"}