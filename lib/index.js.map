{"version":3,"file":"index.js","sources":["../src/Comps/Decorators/fromDefaultValue.js","../src/Comps/Views/undefinedWidgetFactory.js","../src/Comps/Decorators/labeled.js","../src/Comps/Views/Input.js","../src/Comps/Views/TextWidget.js","../src/Comps/Views/ArrowNumberWidget.js","../src/Comps/Views/CheckboxWidget.js","../src/Comps/Views/ArrayWidget.js","../src/Comps/Views/ObjectWidget.js","../src/Comps/Views/SelectWidget.js","../src/Comps/Views/index.js","../src/Comps/Views/Widget.js","../src/Utils/customValidator.js","../src/Comps/Decorators/validator.js","../src/Comps/Fields/Object.js","../src/Comps/Fields/String.js","../src/Comps/Fields/Boolean.js","../src/Comps/Fields/Array.js","../src/Comps/Decorators/visible.js","../src/Comps/Fields/Undefined.js","../src/Utils/infer.js","../src/Comps/Decorators/inference.js","../src/Comps/SchemaType.js","../src/Store/actions.js","../src/Store/index.js","../src/Comps/Fields/Number.js","../src/Comps/Fields/index.js","../src/Comps/Container.js","../src/index.js"],"sourcesContent":["import React, { PropTypes } from 'react';\n\nfunction updateDefault({ value, schema: { value: defaultValue } }) {\n    const val = value !== undefined ? value : defaultValue;\n    return val;\n}\n\nfunction fromDefaultValue(Comp) {\n    class DefaultValue extends React.Component {\n        constructor(props) {\n            super(props);\n            this.state = { val: updateDefault(props) };\n        }\n        componentDidMount() {\n            this.notifyDefaultChange();\n        }\n        componentWillReceiveProps(nextProps) {\n            this.setState({ val: updateDefault(nextProps) });\n        }\n        componentDidUpdate() {\n            this.notifyDefaultChange();\n        }\n        notifyDefaultChange() {\n            if (this.props.value !== this.state.val) {\n                this.props.actions.setDefaultValue(this.props.path, this.state.val);\n            }\n        }\n        render() {\n            return (<Comp {...this.props} value={this.state.val} />);\n        }\n    }\n\n    DefaultValue.propTypes = {\n        value: PropTypes.any, // eslint-disable-line\n        schema: PropTypes.shape({ // eslint-disable-line\n            value: PropTypes.any\n        }).isRequired,\n        path: PropTypes.arrayOf(PropTypes.string).isRequired,\n        actions: PropTypes.shape({\n            setDefaultValue: PropTypes.func.isRequired\n        }).isRequired\n    };\n    return DefaultValue;\n}\n\nexport default fromDefaultValue;\n","import React from 'react';\n\nfunction undefinedWidgetFactory(type) {\n    return function UndefinedWidget() {\n        return (\n            <span>\n                {`Widget for '${type}' was not defined`}\n            </span>\n        );\n    };\n}\n\nexport default undefinedWidgetFactory;\n","import React, { PropTypes } from 'react';\n\nfunction labeled(Comp) {\n    function label(props) {\n        const required = props.schema.required;\n        const requiredClassName = required ? 'required' : '';\n        return (\n            <div>\n                <label //eslint-disable-line\n                    className={`${props.schema.type}Field ${requiredClassName}`}\n                >\n                    <span className=\"title\">{props.view.title || props.editKey}</span>\n                    <Comp {...props} />\n                    <span>{props.view.description}</span>\n                    <span>{props.errorMessage}</span>\n                </label>\n            </div>\n        );\n    }\n\n    label.propTypes = {\n        schema: PropTypes.shape({\n            type: PropTypes.oneOfType([\n                PropTypes.oneOf(['object', 'string', 'number', 'array', 'boolean']),\n                PropTypes.arrayOf(\n                    PropTypes.oneOf(['object', 'string', 'number', 'array', 'boolean', 'null'])\n                )\n            ]).isRequired,\n            required: PropTypes.bool,\n            description: PropTypes.string\n        }),\n        editKey: PropTypes.any,\n        view: PropTypes.object,\n        errorMessage: PropTypes.arrayOf(PropTypes.string)\n    };\n    return label;\n}\n\nexport default labeled;\n","import React, { PropTypes } from 'react';\n\nfunction onInputChange(func) {\n    return function onChange(event) {\n        if (event.target.type === 'checkbox') {\n            func(event.target.checked);\n        } else {\n            func(event.target.value);\n        }\n    };\n}\n\nfunction Input(props) {\n    return (\n        <input\n            type={props.type}\n            placeholder={props.schema.placeholder}\n            value={props.value}\n            className={props.className}\n            onChange={onInputChange(props.onChange)}\n            checked={props.checked}\n        />\n    );\n}\n\nInput.propTypes = {\n    type: PropTypes.string.isRequired,\n    defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    className: PropTypes.string,\n    onChange: PropTypes.func.isRequired,\n    checked: PropTypes.bool,\n    value: PropTypes.any,\n    schema: PropTypes.shape({\n        placeholder: PropTypes.string\n    })\n};\nexport default Input;\n","import React from 'react';\nimport labeled from '../Decorators/labeled';\nimport Input from './Input';\n\nfunction TextWidget(props) {\n    return (\n        <Input\n            {...props}\n            type=\"string\"\n        />\n    );\n}\n\nexport default labeled(TextWidget);\n","import React from 'react';\nimport labeled from '../Decorators/labeled';\nimport Input from './Input';\n\nfunction ArrowNumberWidget(props) {\n    return (\n        <Input\n            {...props}\n            type=\"number\"\n        />\n    );\n}\n\nexport default labeled(ArrowNumberWidget);\n","import React, { PropTypes } from 'react';\nimport labeled from '../Decorators/labeled';\nimport Input from './Input';\n\nfunction CheckboxWidget(props) {\n    return (\n        <Input\n            {...props}\n            type=\"checkbox\"\n            checked={props.value}\n        />\n    );\n}\n\nCheckboxWidget.propTypes = {\n    value: PropTypes.bool\n};\n\nexport default labeled(CheckboxWidget);\n","import React, { PropTypes } from 'react';\nimport labeled from '../Decorators/labeled';\n\nfunction ArrayWidget(props) {\n    function renderChild(child, index) {\n        return (<div>\n            <span onClick={props.onChildRemove(index)}>-</span>\n            {child}\n        </div>);\n    }\n\n    const children = React.Children.map(props.children, renderChild);\n    return (\n        <div>\n            <div>\n                {children}\n            </div>\n            <span onClick={props.onChildAdd}>+</span>\n        </div>\n    );\n}\n\nArrayWidget.propTypes = {\n    children: PropTypes.arrayOf(PropTypes.element),\n    onChildRemove: PropTypes.func.isRequired,\n    onChildAdd: PropTypes.func.isRequired\n};\nexport default labeled(ArrayWidget);\n","import React, { PropTypes } from 'react';\nimport labeled from '../Decorators/labeled';\n\nfunction ObjectWidget(props) {\n    return (\n        <div>\n            {props.children}\n        </div>\n    );\n}\n\nObjectWidget.propTypes = {\n    children: PropTypes.arrayOf(PropTypes.element)\n};\n\nexport default labeled(ObjectWidget);\n","import React, { PropTypes } from 'react';\n\nfunction SelectWidget({ view, value, onChange }) {\n    const choices = view.choices.map(c => (\n        <option\n            key={c.value}\n            value={c.value}\n        >\n            {c.label}\n        </option>\n    ));\n    return (\n        <select value={value} onChange={e => onChange(e.target.value)}>\n            {choices}\n        </select>\n    );\n}\nSelectWidget.propTypes = {\n    view: PropTypes.shape({\n        choices: PropTypes.arrayOf(PropTypes.shape({\n            value: PropTypes.any,\n            label: PropTypes.string.isRequired\n        })).isRequired\n    }),\n    value: PropTypes.any,\n    onChange: PropTypes.func.isRequired\n};\nexport default SelectWidget;\n","import undefinedWidgetFactory from './undefinedWidgetFactory';\nimport TextWidget from './TextWidget';\nimport ArrowNumberWidget from './ArrowNumberWidget';\nimport CheckboxWidget from './CheckboxWidget';\nimport ArrayWidget from './ArrayWidget';\nimport ObjectWidget from './ObjectWidget';\nimport SelectWidget from './SelectWidget';\n\nlet DefaultWidget = {\n    string: TextWidget,\n    number: TextWidget,\n    boolean: CheckboxWidget,\n    array: ArrayWidget,\n    object: ObjectWidget,\n    arrowNumber: ArrowNumberWidget,\n    select: SelectWidget\n};\n\nfunction defaultWidget(type) {\n    return DefaultWidget[type] || undefinedWidgetFactory(type);\n}\n\nfunction setDefaultWidgets(obj) {\n    DefaultWidget = Object.assign({}, DefaultWidget, obj);\n}\n\nexport { defaultWidget, setDefaultWidgets, undefinedWidgetFactory };\n","import React, { PropTypes } from 'react';\nimport { defaultWidget } from './index';\n\nconst EMPTYOBJECT = {};\nfunction Widget(props) {\n    const { schema } = props;\n    const { view, ...restSchema } = schema;\n    if (view) {\n        const { type } = view;\n        if (typeof type === 'string') {\n            const Wdgt = defaultWidget(type);\n            return (\n                <Wdgt\n                    {...props}\n                    schema={restSchema}\n                    view={view}\n                />\n            );\n        }\n        if (typeof type === 'function') {\n            const Type = type;\n            return (\n                <Type\n                    {...props}\n                    schema={restSchema}\n                    view={view}\n                />\n            );\n        }\n    }\n    const renderType = Array.isArray(schema.type) ?\n        schema.type.find(t => t !== 'null') :\n        schema.type;\n    const Wdgt = defaultWidget(renderType);\n    return (\n        <Wdgt\n            {...props}\n            schema={restSchema}\n            view={view || EMPTYOBJECT}\n        />\n    );\n}\n\nWidget.propTypes = {\n    schema: PropTypes.object,\n    path: PropTypes.array,\n    actions: PropTypes.objectOf(PropTypes.func)\n};\nexport default Widget;\n","import jsonschema, { Validator } from 'jsonschema';\n\nconst customValidator = new Validator();\ncustomValidator.attributes.errored = function validateErrored(instance, schema, options) {\n    if (typeof schema.errored !== 'function') {\n        throw new jsonschema.SchemaError('\"errored\" expects a function');\n    }\n    const msg = schema.errored(instance, options.formValue);\n    if (msg) {\n        return msg;\n    }\n    return undefined;\n};\nfunction validate(value, schema, formValue) {\n    return customValidator.validate(value, schema, {\n        formValue\n    });\n}\n\nexport default validate ;\n","import React, { PropTypes } from 'react';\nimport validate from './../../Utils/customValidator';\n\nfunction validated(Comp) {\n    function Validator(props) {\n        function onChange(val) {\n            const validation = validate(val, props.schema, props.actions.getFormValue());\n            const err = validation.errors.map(error => error.message);\n            props.onChange(val, err);\n        }\n\n        return (\n            <Comp\n                {...props}\n                errorMessage={props.actions.getErrors(props.path)}\n                onChange={onChange}\n            />\n        );\n    }\n\n    Validator.propTypes = {\n        onChange: PropTypes.func.isRequired,\n        schema: PropTypes.shape({\n            errored: PropTypes.func\n        }),\n        value: PropTypes.any,\n        path: PropTypes.array.isRequired,\n        actions: PropTypes.objectOf(PropTypes.func).isRequired\n    };\n    return Validator;\n}\n\nexport default validated;\n","import React, { PropTypes } from 'react';\nimport SchemaType from '../SchemaType';\nimport fromDefaultValue from '../Decorators/fromDefaultValue';\nimport Widget from '../Views/Widget';\nimport validator from '../Decorators/validator';\n\n\nfunction renderChildren(props) {\n    const children = [];\n    const properties = props.schema.properties || {};\n    const value = props.value || {};\n    // Holds schema properties and value properties missing from schema.\n    const mergedProperties = Object.keys(properties);\n    // mergedProperties.concat(Object.values(value));\n    Object.keys(value).forEach(v => {\n        if (v in properties) {\n            return;\n        }\n        mergedProperties.push(v);\n    });\n\n    // Index based sorting\n    function sortProperties(a, b) {\n        const aIndex = properties[a] ? properties[a].index || 0 : 0;\n        const bIndex = properties[b] ? properties[b].index || 0 : 0;\n        return aIndex - bIndex;\n    }\n\n    mergedProperties.sort(sortProperties);\n    for (let i = 0; i < mergedProperties.length; i += 1) {\n        const prop = mergedProperties[i];\n        if (prop in properties) {\n            children.push(\n                <SchemaType\n                    {...props}\n                    schema={properties[prop]}\n                    value={value[prop]}\n                    editKey={prop}\n                    key={prop}\n                />\n            );\n        } else {\n            const schema = props.schema.defaultProperties;\n            children.push(\n                <SchemaType\n                    {...props}\n                    schema={schema}\n                    value={value[prop]}\n                    editKey={prop}\n                    key={prop}\n                />\n            );\n        }\n    }\n    return children;\n}\n\nfunction ObjectField(props) {\n    function addKey(key, value) {\n        props.onChange(Object.assign({}, props.value, {\n            [key]: value\n        }));\n    }\n\n    function removeKey(key) {\n        const value = Object.assign({}, props.value);\n        delete value[key];\n        props.onChange(value);\n    }\n\n    function alterKey(key, newKey) {\n        const value = {};\n        Object.keys(props.value).forEach(p => {\n            if (p !== key) {\n                value[p] = props.value[p];\n            } else {\n                value[newKey] = props.value[p];\n            }\n        });\n        props.onChange(value);\n    }\n\n    return (\n        <Widget\n            {...props}\n            addKey={addKey}\n            removeKey={removeKey}\n            alterKey={alterKey}\n        >\n            {renderChildren(props)}\n        </Widget>\n    );\n}\n\nObjectField.propTypes = {\n    schema: PropTypes.shape({\n        properties: PropTypes.object\n    }),\n    children: PropTypes.node,\n    value: PropTypes.any,\n    path: PropTypes.arrayOf(PropTypes.string),\n    onChange: PropTypes.func.isRequired\n};\n\nexport default validator(fromDefaultValue(ObjectField));\n","import React, { PropTypes } from 'react';\nimport Widget from '../Views/Widget';\nimport fromDefaultValue from '../Decorators/fromDefaultValue';\nimport validator from '../Decorators/validator';\n\nfunction StringField(props) {\n    const val = props.value !== undefined && props.value !== null ?\n        String(props.value) :\n        props.value;\n    return (\n        <Widget\n            {...props}\n            value={val}\n        />\n    );\n}\n\nStringField.propTypes = {\n    value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    schema: PropTypes.shape({\n        defaultValue: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n        type: PropTypes.oneOfType([\n            PropTypes.oneOf(['string', 'number']),\n            PropTypes.arrayOf(\n                PropTypes.oneOf(['string', 'number', 'null'])\n            )\n        ]).isRequired\n    }),\n    onChange: PropTypes.func.isRequired\n};\nexport { StringField as SimpleStringField };\nexport default validator(fromDefaultValue(StringField));\n","import React from 'react';\nimport Widget from '../Views/Widget';\nimport fromDefaultValue from '../Decorators/fromDefaultValue';\nimport validator from './../Decorators/validator';\n\nfunction BooleanField(props) {\n    return (<Widget {...props} />);\n}\n\nexport default validator(fromDefaultValue(BooleanField));\n","import React from 'react';\nimport SchemaType from '../SchemaType';\nimport Widget from '../Views/Widget';\nimport fromDefaultValue from '../Decorators/fromDefaultValue';\n\nfunction onChildChange(index, props) {\n    return function onChange(val) {\n        const { value } = props;\n        if (value) {\n            props.onChange(value.map((e, i) => {\n                if (+i !== +index) {\n                    return e;\n                }\n                return val;\n            }));\n        } else {\n            props.onChange([val]);\n        }\n    };\n}\n\nfunction onChildRemove(props) {\n    return function onRemove(index) {\n        return function doRemove() {\n            const oldValue = props.value || [];\n            props.onChange(oldValue.filter((e, i) => Number(i) !== Number(index)));\n        };\n    };\n}\n\nfunction onChildAdd(props) {\n    return function onAdd() {\n        const oldValue = props.value || [];\n        props.onChange(oldValue.concat([undefined]));\n    };\n}\n\nfunction renderChildren(props) {\n    const { value, schema: { defaultValue, items } } = props;\n    let valueItems;\n    if (value) {\n        valueItems = value;\n    } else if (defaultValue) {\n        valueItems = defaultValue;\n    } else {\n        valueItems = [];\n    }\n    const children = [];\n    valueItems.forEach((val, i) => children.push(\n        <SchemaType\n            {...props}\n            schema={Array.isArray(items) ? (items[i] || {}) : items}\n            value={val}\n            editKey={String(i)}\n            key={i}\n            onChange={onChildChange(i, props)}\n        />\n    ));\n    return children;\n}\n\nfunction ArrayField(props) {\n    return (\n        <Widget\n            {...props}\n            onChildAdd={onChildAdd(props)}\n            onChildRemove={onChildRemove(props)}\n        >\n            {renderChildren(props)}\n        </Widget>\n    );\n}\n\nexport default fromDefaultValue(ArrayField);\n","import React, { PropTypes } from 'react';\n\nfunction visibility(Comp) {\n    function Visible(props) {\n        const { schema: { visible }, value } = props;\n        if (visible && !visible(value, props.actions.getFormValue())) {\n            return null;\n        }\n        return (<Comp {...props} />);\n    }\n\n    Visible.propTypes = {\n        schema: PropTypes.shape({\n            visible: PropTypes.func\n        }),\n        actions: PropTypes.objectOf(PropTypes.func),\n        value: PropTypes.any\n    };\n    return Visible;\n}\n\nexport default visibility;\n","import React, { PropTypes } from 'react';\n\nfunction Undefined(props) {\n    return (<span>{`Undefined field type \"${props.schema.type}\", [${props.path}]`}</span>);\n}\n\nUndefined.propTypes = {\n    schema: PropTypes.shape({\n        type: PropTypes.oneOfType([\n            PropTypes.oneOf(['object', 'string', 'number', 'array', 'boolean']),\n            PropTypes.arrayOf(\n                PropTypes.oneOf(['object', 'string', 'number', 'array', 'boolean', 'null'])\n            )\n        ]).isRequired\n    }),\n    path: PropTypes.array\n};\nexport default Undefined;\n","export default function infer(value) {\n    switch (typeof value) {\n    case 'number':\n        return 'number';\n    case 'string':\n        return 'string';\n    case 'boolean':\n        return 'boolean';\n    case 'object':\n        return Array.isArray(value) ? 'array' : 'object';\n    default:\n        return 'string';\n    }\n}\n","import React, { PropTypes } from 'react';\nimport infer from './../../Utils/infer.js';\n/**\n * Update store's value path.\n * @param {Array<string>} currentValuePath the valuePath the parent\n * @param {string} editKey the key currently edited\n * @returns {Array<string>}the updated valuePath\n */\nfunction updatePath(currentPath, editKey) {\n    if (editKey) {\n        return currentPath.concat([editKey]);\n    }\n    return currentPath;\n}\n\n/**\n * HOC, compute schema value from inferred type if schema is missing\n * @param {React.Component} Comp component to decorate.\n * @return {React.Component} the decorated component.\n */\nfunction inference(Comp) {\n    function Infer(props) {\n        const { schema } = props;\n        const path = updatePath(props.path, props.editKey);\n        let inferedSchema = schema;\n        if (!inferedSchema || !('type' in inferedSchema)) {\n            inferedSchema = { type: infer(props.value) };\n            // props.actions.updateSchema(path, schema);\n        }\n        return (\n            <Comp\n                {...props}\n                path={path}\n                schema={inferedSchema}\n            />\n        );\n    }\n\n    Infer.propTypes = {\n        schema: PropTypes.object,\n        value: PropTypes.any,\n        path: PropTypes.arrayOf(PropTypes.string).isRequired,\n        editKey: PropTypes.string,\n       // actions: PropTypes.objectOf(PropTypes.func).isRequired\n    };\n    return Infer;\n}\n\nexport default inference;\n","import React, { PropTypes } from 'react';\nimport shouldPureComponentUpdate from 'react-pure-render/function';\nimport Fields from './Fields/index';\nimport visible from './Decorators/visible';\nimport UndefinedField from './Fields/Undefined';\nimport inference from './Decorators/inference';\n\n\n/**\n * bind function callback with its path\n * @param {function(Array<String>)} func callback function to bind\n * @param {Array<string>} path the value's path to act on\n */\nfunction doAction(func, path) {\n    return function action(...args) {\n        func(path, ...args);\n    };\n}\n\n/**\n * Component generating the correct field based on schema.type\n * @constructor\n * @param {Object} props\n */\nclass SchemaType extends React.Component {\n    constructor(props) {\n        super(props);\n        this.onChange = doAction(props.actions.update, props.path);\n    }\n    shouldComponentUpdate(...args) {\n        return shouldPureComponentUpdate.apply(this, args);\n    }\n    render() {\n        const { schema: { type } } = this.props;\n        const renderType = Array.isArray(type) ? type.find(t => t !== 'null') : type;\n        const Type = Fields[renderType] || UndefinedField;\n        return (\n            <Type\n                {...this.props}\n                onChange={this.onChange}\n            />\n        );\n    }\n}\n\nSchemaType.propTypes = {\n    schema: PropTypes.shape({\n        type: PropTypes.oneOfType([\n            PropTypes.oneOf(['object', 'string', 'number', 'array', 'boolean']),\n            PropTypes.arrayOf(\n                PropTypes.oneOf(['object', 'string', 'number', 'array', 'boolean', 'null'])\n            )\n        ]).isRequired\n    }).isRequired,\n    path: PropTypes.arrayOf(PropTypes.string).isRequired,\n    actions: PropTypes.objectOf(PropTypes.func).isRequired\n};\n\nexport default inference(visible(SchemaType));\n","const VALUE = 'value';\nconst STATUS = 'status';\nconst STATE = 'state';\nconst ERRORS = 'errors';\nconst NOERRORS = [];\n\nexport function setErrors(tree, path, errors) {\n    const errorPath = [STATUS].concat(path).concat([ERRORS]);\n    const errorsCursor = tree.select(errorPath);\n    if (errors && errors.length && Array.isArray(errorsCursor.get())) {\n        errorsCursor.splice([0, errorsCursor.get().length]);\n        errorsCursor.concat(errors || []);\n    } else {\n        errorsCursor.set(errors || NOERRORS);\n    }\n}\n\n/**\n * Update a value in the tree\n *\n * @param {Baobab} tree the tree\n * @param {Array<string>} path path's value to update\n * @param value value to set\n * @param {Array<string>} errors errors relative to the value\n */\nexport function update(tree, path, value, errors) {\n    const statusPath = [STATUS].concat(path);\n    tree.set([VALUE].concat(path), value);\n    tree.set(statusPath.concat([STATE]), 'dirty');\n    setErrors(tree, path, errors);\n}\n\nexport function setDefaultValue(tree, path, value) {\n    tree.set([VALUE].concat(path), value);\n    tree.set([STATUS].concat(path).concat([STATE]), 'pristine');\n}\n\nexport function getStatus(tree, path) {\n    return tree.get([STATUS].concat(path).concat([STATE]));\n}\n\nexport function getErrors(tree, path) {\n    return tree.get([STATUS].concat(path).concat([ERRORS])) || NOERRORS;\n}\n\nexport function getFormValue(tree) {\n    return tree.get(VALUE);\n}\n\nexport function updateSchema(tree, path, value) {\n    const updatedPath = path.reduce((prev, val) => {\n        if (tree.get(prev).type === 'object') {\n            return prev.concat(['properties', val]);\n        } else if (tree.get(prev).type === 'array') {\n            return prev.concat(['items']);\n        }\n        return prev.concat([val]);\n    }, ['schema']);\n    tree.set(updatedPath, value);\n}\n","import Baobab from 'baobab';\n\nconst createTree = () => new Baobab({\n    schema: {},\n    value: {},\n    status: {}\n});\n\nexport default createTree;\n","import React, { PropTypes } from 'react';\nimport validator from '../Decorators/validator';\nimport fromDefaultValue from '../Decorators/fromDefaultValue';\nimport { SimpleStringField } from './String';\n\nclass NumberField extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            value: props.value\n        };\n        this.boundChange = this.onChange.bind(this);\n    }\n    componentWillReceiveProps(nextProps) {\n        // if numerical values differ: update\n        if (Number(this.state.value) !== Number(nextProps.value)) {\n            this.setState({\n                value: nextProps.value\n            });\n        }\n    }\n    onChange(val) {\n        const value = val === '' ? undefined : val;\n        const numVal = Number(value);\n        this.setState({\n            value\n        }, () => this.props.onChange(isNaN(numVal) ? value : numVal));\n    }\n    render() {\n        return (\n            <SimpleStringField\n                {...this.props}\n                value={this.state.value}\n                onChange={this.boundChange}\n            />\n        );\n    }\n}\nNumberField.propTypes = {\n    value: PropTypes.number,\n    onChange: PropTypes.func.isRequired\n};\n\nexport default validator(fromDefaultValue(NumberField));\n","import ObjectField from './Object';\nimport StringField from './String';\nimport NumberField from './Number';\nimport BooleanField from './Boolean';\nimport ArrayField from './Array';\n\nexport default {\n    object: ObjectField,\n    string: StringField,\n    number: NumberField,\n    boolean: BooleanField,\n    array: ArrayField\n};\n","import React, { PropTypes } from 'react';\nimport { root, branch } from 'baobab-react/higher-order';\nimport createTree from '../Store/index';\nimport SchemaType from './SchemaType';\nimport * as actions from '../Store/actions';\nimport validate from './../Utils/customValidator';\n\nconst BranchedSchemaType = branch({\n    schema: 'schema',\n    status: 'status',\n    value: 'value'\n}, SchemaType);\nconst TYPES = ['string', 'number', 'boolean', 'object', 'array', 'null'];\n/**\n * Top Component\n */\nclass Container extends React.Component {\n    constructor(props) {\n        super(props);\n        this.tree = createTree();\n        this.updateTree(props.value, props.schema);\n        // should use dispatcher instead. from baobab-react v2\n        this.ACTIONS = {};\n        Object.keys(actions)\n            .forEach(action => (\n                this.ACTIONS[action] = actions[action].bind(this.tree, this.tree)\n            ));\n        this.rooted = root(this.tree, BranchedSchemaType);\n    }\n    componentWillReceiveProps(nextProps) {\n        this.updateTree(nextProps.value, nextProps.schema);\n    }\n    shouldComponentUpdate() {\n        return false;\n    }\n    componentWillUnmount() {\n        this.tree.release();\n    }\n    getValue() {\n        return this.tree.get('value');\n    }\n    updateTree(value, schema) {\n        this.tree.select('value').release();\n        this.tree.select('value').set(value);\n        this.tree.select('schema').set(schema);\n        this.tree.select('status').release();\n        this.tree.commit();\n        this.tree.select('value')\n            .on('update', event =>\n                this.props.onChange(\n                    event.data.currentData,\n                    validate(\n                        event.data.currentData,\n                        this.tree.get('schema'),\n                        event.data.currentData\n                    ).errors\n                )\n            );\n    }\n    validate() {\n        const validationResult = validate(this.tree.get('value'),\n            this.tree.get('schema'), this.tree.get('value'));\n        const { setErrors } = this.ACTIONS;\n        const errorMap = new Map();\n        // Collect each error associated with a given path\n        validationResult.errors.forEach((error) => {\n            const errors = errorMap.get(error.property) || [];\n            errors.push(error.message); // Add new error\n            errorMap.set(error.property, errors);\n        });\n        errorMap.forEach((value, key) => {\n            setErrors(key.split(/\\.|\\[|\\]/).filter(x => x !== '').slice(1), value);\n        });\n        return validationResult.errors;\n    }\n    render() {\n        const Rooted = this.rooted;\n        return (\n            <Rooted\n                onChange={this.props.onChange}\n                path={[]}\n                actions={this.ACTIONS}\n            />\n        );\n    }\n}\nContainer.propTypes = {\n    onChange: PropTypes.func.isRequired,\n    schema: PropTypes.shape({\n        type: PropTypes.oneOfType([PropTypes.oneOf(TYPES),\n            PropTypes.arrayOf(PropTypes.oneOf(TYPES))])\n    }),\n    value: PropTypes.any // eslint-disable-line\n};\nContainer.defaultProps = {\n    schema: {}\n};\n\nexport default Container;\n","import Container from './Comps/Container';\nimport { setDefaultWidgets } from './Comps/Views/index';\n\nContainer.setDefaultWidgets = setDefaultWidgets;\nexport default Container;\n"],"names":["updateDefault","value","defaultValue","schema","val","undefined","fromDefaultValue","Comp","DefaultValue","props","_React$Component","state","componentDidMount","notifyDefaultChange","componentWillReceiveProps","nextProps","setState","componentDidUpdate","this","actions","setDefaultValue","path","render","React","Component","undefinedWidgetFactory","type","labeled","label","required","requiredClassName","className","view","title","editKey","description","errorMessage","onInputChange","func","event","target","checked","Input","placeholder","onChange","TextWidget","ArrowNumberWidget","CheckboxWidget","ArrayWidget","renderChild","child","index","onClick","onChildRemove","children","Children","map","onChildAdd","ObjectWidget","SelectWidget","choices","c","e","defaultWidget","DefaultWidget","setDefaultWidgets","obj","Object","assign","Widget","restSchema","Wdgt","_Wdgt","Type","renderType","Array","isArray","find","t","EMPTYOBJECT","validate","formValue","customValidator","validated","Validator","validation","getFormValue","err","errors","error","message","getErrors","renderChildren","sortProperties","a","b","aIndex","properties","bIndex","mergedProperties","keys","forEach","v","push","sort","i","length","prop","SchemaType","defaultProperties","ObjectField","addKey","key","removeKey","alterKey","newKey","p","StringField","String","BooleanField","onChildChange","oldValue","filter","Number","concat","items","valueItems","ArrayField","visibility","Visible","visible","Undefined","infer","updatePath","currentPath","inference","Infer","inferedSchema","doAction","args","setErrors","tree","errorPath","STATUS","ERRORS","errorsCursor","select","get","splice","set","NOERRORS","update","statusPath","VALUE","STATE","getStatus","updateSchema","updatedPath","reduce","prev","createTree","Baobab","attributes","errored","instance","options","jsonschema","SchemaError","msg","validator","NumberField","boundChange","_this","bind","numVal","_this2","isNaN","SimpleStringField","shouldComponentUpdate","shouldPureComponentUpdate","apply","Fields","UndefinedField","BranchedSchemaType","branch","Container","updateTree","ACTIONS","action","rooted","root","componentWillUnmount","release","getValue","commit","on","data","currentData","validationResult","errorMap","Map","property","split","x","slice","Rooted","defaultProps"],"mappings":"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"}